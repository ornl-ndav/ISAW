package IsawGUI;

/**
 * $Id$
 *
 * encapsulates all event handling for a JDataTree.  generates
 * appropriate right-click menus for selections and handles the
 * events generated by the menus.  this includes selecting and
 * clearing selection of Data and DataSet objects, deleting tree
 * nodes, applying operators to DataSet objects, creating views
 * of DataSet objects, and all of the other actions that are
 * associated with the generated right-click menu.
 *
 * $Log$
 * Revision 1.2  2001/06/27 20:19:36  neffk
 * added the appropriate constructor so that JTreeUI and CommandPane can
 * remain up to date when the menus provided by this class change the DataSet
 * objects.
 *
 * Revision 1.1  2001/06/25 21:30:54  neffk
 * handles all menus and operations for JTreeUI.
 *
 */


import DataSetTools.components.ui.OperatorMenu;
import DataSetTools.dataset.Data;
import DataSetTools.dataset.DataSet;
import DataSetTools.util.IObserver;
import DataSetTools.operator.Operator;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import javax.swing.JPopupMenu;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.tree.TreePath;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.text.Document;


public class JDataTreeRingmaster
{

  final String MENU_SELECT    = "Select";
  final String MENU_CLEAR     = "Clear";
  final String MENU_CLEAR_ALL = "Clear All Selections";
  final String MENU_DELETE    = "Delete";


  JTreeUI tree;                  //need this because of some 
  Document sessionLog = null;    //unpleasant coupling of the tree
                                 //the command pane, and various other stuff...

  JDataTreeRingmaster( JTreeUI tree_ )
  {
    tree = tree_;
  }


  JDataTreeRingmaster( JTreeUI tree_, Document log )
  {
    tree = tree_;
    sessionLog = log;
  }


  /**
   * decides what kind of menu should be generated.  there are five (5)
   * types of menus that can be generated:
   *
   *   0) single Data object selection
   *   1) multiple Data object selection
   *   2) single DataSet object selection
   *   3) multiple DataSet object selection
   *   4) runfile selection
   *
   * all selected nodes of unknown types are ignored.
   */
  public void generatePopupMenu( TreePath[] tp, MouseEvent e )
  {
    DataSet ds = traverseUpToDataSet( tp[0] );
    DefaultMutableTreeNode dmtn = null;
    if(  tp.length > 0  )
      dmtn = (DefaultMutableTreeNode)(  tp[0].getLastPathComponent()  );

    //
    // single Data object
    //
    if(   dmtn.getUserObject() instanceof Data  &&  tp.length == 1   )
    {
      SingleDataBlockPopupMenu( tp, e );
    }

    //
    // multiple Data objects
    //
    else if(  dmtn.getUserObject() instanceof Data  )
    {
      for( int i=0;  i<tp.length;  i++ )
      {
        dmtn = (DefaultMutableTreeNode)(  tp[i].getLastPathComponent()  );

        if(  !ds.equals( traverseUpToDataSet(tp[i]) )  ||        //only use first DataSet's Data.
             !(dmtn.getUserObject() instanceof Data )  )         //make sure we're dealing with a group of
        {                                                        //consistant objects.
          System.out.println( "non-Data or illegal multiple DataSet selection" );
          return;
        }
      }
      MultipleDataBlockPopupMenu( tp, e );
    }

    //
    // single DataSet object
    //
    else if(  dmtn.getUserObject() instanceof DataSet  &&  tp.length == 1  )
    {
      SingleDataSetPopupMenu( tp, e );
    }

    //
    // multiple DataSet objects
    //
    else if(  dmtn.getUserObject() instanceof DataSet  )
    {
      for( int i=0;  i<tp.length;  i++ )
      {
        dmtn = (DefaultMutableTreeNode)(  tp[i].getLastPathComponent()  );

        if(   ds.equals( traverseUpToDataSet( tp[i] ) )  &&    //only use first DataSet's Data.
              dmtn.getUserObject() instanceof DataSet   )       //make sure we're dealing with a group of
        {                                                        //consistant objects.
          MultipleDataSetPopupMenu( tp, e );
        }
      }
    }
    else
    {
      System.out.println( "type not appropriate for actionMenu" );
    }
  }


  /**
   * creates a popup menu that is appropriate for a single
   * Data object when the user right-clicks on it.
   */
  public void SingleDataBlockPopupMenu( TreePath[] tp, MouseEvent e )
  {

    class SingleDataBlockMenuItemListener
      implements ActionListener
    {
      TreePath[] tps;

      public SingleDataBlockMenuItemListener( TreePath[] tps_ )
      {
        tps = tps_;
      }

      public void actionPerformed( ActionEvent item_e )
      {
        if(  item_e.getActionCommand() == MENU_SELECT  )
        {
          for( int i=0;  i<tps.length;  i++ )
          {
            DefaultMutableTreeNode dmtn = (DefaultMutableTreeNode)(  tps[i].getLastPathComponent()  );
            Data d = (Data)dmtn.getUserObject();
            d.setSelected( true );
          }
          DataSet _ds = traverseUpToDataSet( tps[0] );
          _ds.notifyIObservers( IObserver.SELECTION_CHANGED );
        }
        else if(  item_e.getActionCommand() == MENU_CLEAR  )
        {
          DefaultMutableTreeNode dmtn = (DefaultMutableTreeNode)(  tps[0].getLastPathComponent()  );
          Data d = (Data)dmtn.getUserObject();
          d.setSelected( false );
          DataSet _ds = traverseUpToDataSet( tps[0] );
          _ds.notifyIObservers( IObserver.SELECTION_CHANGED );
        }
        else if(  item_e.getActionCommand() == MENU_CLEAR_ALL  )
        {
          DataSet ds = traverseUpToDataSet( tps[0] );
          for( int i=0;  i<ds.getNum_entries();  i++ )
            ds.getData_entry(i).setSelected( false );

          DataSet _ds = traverseUpToDataSet( tps[0] );
          _ds.notifyIObservers( IObserver.SELECTION_CHANGED );
        }
        else if(  item_e.getActionCommand() == MENU_DELETE  )
        {
          DataSet ds = traverseUpToDataSet( tps[0] );
          DefaultMutableTreeNode dmtn = (DefaultMutableTreeNode)(  tps[0].getLastPathComponent()  );
          Data d = (Data)dmtn.getUserObject();
          ds.removeData_entry_with_id(  d.getGroup_ID()  );
          ds.notifyIObservers( IObserver.DATA_DELETED );
        }
      }
    }
    SingleDataBlockMenuItemListener item_listener = null;
    item_listener = new SingleDataBlockMenuItemListener( tp );

    JMenuItem select_item = new JMenuItem( MENU_SELECT );
              //select_item.setMnemonic( KeyEvent.VK_S );
              select_item.addActionListener( item_listener );
    JMenuItem clear_item = new JMenuItem( MENU_CLEAR );
              //clear_item.setMnemonic( KeyEvent.VK_BACK_SPACE );
              clear_item.addActionListener( item_listener );
    JMenuItem clear_all_item = new JMenuItem( MENU_CLEAR_ALL );
              //clear_all_item.setMnemonic( KeyEvent.VK_S );
              clear_all_item.addActionListener( item_listener );
    JMenuItem delete_item = new JMenuItem( MENU_DELETE );
              //delete_item.setMnemonic( KeyEvent.VK_X );
              delete_item.addActionListener( item_listener );
    JPopupMenu popup_menu = new JPopupMenu( "SingleDataBlockPopupMenu" );
               popup_menu.add( select_item );
               popup_menu.add( clear_item );
               popup_menu.add( clear_all_item );
               popup_menu.add( delete_item );
               popup_menu.show(  e.getComponent(), e.getX(), e.getY()  );
  }


  /**
   * creates a popup menu that is appropriate for multiple
   * Data objects when the user right-clicks on the highlighted
   * items.
   */
  public void MultipleDataBlockPopupMenu( TreePath[] tp, MouseEvent e )
  {

    class MultipleDataBlockMenuItemListener
      implements ActionListener
    {
      TreePath[] tps;

      public MultipleDataBlockMenuItemListener( TreePath[] tps_ )
      {
        tps = tps_;
      }

      public void actionPerformed( ActionEvent item_e )
      {
        if(  item_e.getActionCommand() == MENU_SELECT  )
        {
          for( int i=0;  i<tps.length;  i++ )
          {
            DefaultMutableTreeNode dmtn = (DefaultMutableTreeNode)(  tps[i].getLastPathComponent()  );
            Data d = (Data)dmtn.getUserObject();
            d.setSelected( true );

            DataSet ds = traverseUpToDataSet( tps[0] );
            ds.notifyIObservers( IObserver.SELECTION_CHANGED );
          }
        }
        else if(  item_e.getActionCommand() == MENU_CLEAR  )
        {
          for( int i=0;  i<tps.length;  i++ )
          {
            DefaultMutableTreeNode dmtn = (DefaultMutableTreeNode)(  tps[i].getLastPathComponent()  );
            Data d = (Data)dmtn.getUserObject();
            d.setSelected( false );
   
            DataSet ds = traverseUpToDataSet( tps[0] );
            ds.notifyIObservers( IObserver.SELECTION_CHANGED );
          }
        }
        else if(  item_e.getActionCommand() == MENU_CLEAR_ALL  )
        {
          DataSet _ds = traverseUpToDataSet( tps[0] );
          for( int i=0;  i<_ds.getNum_entries();  i++ )
            _ds.getData_entry(i).setSelected( false );

          DataSet ds = traverseUpToDataSet( tps[0] );
          ds.notifyIObservers( IObserver.SELECTION_CHANGED );
        }
        else if(  item_e.getActionCommand() == MENU_DELETE  )
        {
          DataSet _ds = traverseUpToDataSet( tps[0] );
          for( int i=0;  i<tps.length;  i++ )
          {
            DefaultMutableTreeNode dmtn = (DefaultMutableTreeNode)(  tps[i].getLastPathComponent()  );
            Data d = (Data)dmtn.getUserObject();
            _ds.removeData_entry_with_id(  d.getGroup_ID()  );
          }
          _ds.notifyIObservers( IObserver.DATA_DELETED );
        }
      }
    }
    MultipleDataBlockMenuItemListener item_listener = null;
    item_listener = new MultipleDataBlockMenuItemListener( tp );

    JMenuItem select_item = new JMenuItem( MENU_SELECT );
              //select_item.setMnemonic( KeyEvent.VK_S );
              select_item.addActionListener( item_listener );
    JMenuItem clear_item = new JMenuItem( MENU_CLEAR );
              //clear_item.setMnemonic( KeyEvent.VK_BACK_SPACE );
              clear_item.addActionListener( item_listener );
    JMenuItem clear_all_item = new JMenuItem( MENU_CLEAR_ALL );
              //clear_all_item.setMnemonic( KeyEvent.VK_S );
              clear_all_item.addActionListener( item_listener );
    JMenuItem delete_item = new JMenuItem( MENU_DELETE );
              //delete_item.setMnemonic( KeyEvent.VK_X );
              delete_item.addActionListener( item_listener );
    JPopupMenu popup_menu = new JPopupMenu( "MultipleDataBlockPopupMenu" );
               popup_menu.add( select_item );
               popup_menu.add( clear_item );
               popup_menu.add( clear_all_item );
               popup_menu.add( delete_item );
               popup_menu.show(  e.getComponent(), e.getX(), e.getY()  );
  }


  /**
   * creates a popup menu that is appropriate for a single
   * DataSet object when the user right-clicks on highlighted
   * items.
   */
  public void SingleDataSetPopupMenu( TreePath[] tp, MouseEvent e )
  {
    DefaultMutableTreeNode dmtn = (DefaultMutableTreeNode)(  tp[0].getLastPathComponent()  );
    DataSet ds = (DataSet)dmtn.getUserObject();

    int num_ops = ds.getNum_operators();                //create a sub-menu
    Operator ds_ops[] = new Operator[num_ops];          //for the current
    for ( int i = 0; i < num_ops; i++ )                 //DataSet object
      ds_ops[i] = ds.getOperator(i);

    DataSet[] dss = new DataSet[1];
    dss[0] = ds;
    JMenu ops_popup_menu = new JMenu( "Operations" );
    OperatorMenu om = new OperatorMenu();
//    JPopupMenuListener popup_listener = null;
    JOperationsMenuHandler popup_listener = new JOperationsMenuHandler( dss, tree );
    om.build( ops_popup_menu, ds_ops, popup_listener );
    ops_popup_menu.setPopupMenuVisible( true );

    class singleDataSetMenuItemListener implements ActionListener
    {
      public void actionPerformed( ActionEvent item_e )
      {
        System.out.println( "singleDataSetMenuItemListener> " + item_e.getActionCommand()  );

        if(  item_e.getActionCommand() == MENU_SELECT  )
        {
        }
        if(  item_e.getActionCommand() == MENU_CLEAR  )
        {
        }
        if(  item_e.getActionCommand() == MENU_CLEAR_ALL  )
        {
        }
        if(  item_e.getActionCommand() == MENU_DELETE  )
        {
        
        }
      }
    }

    singleDataSetMenuItemListener item_listener = new singleDataSetMenuItemListener();
//    JMenuItem select_item = new JMenuItem( MENU_SELECT );
//              //select_item.setMnemonic( KeyEvent.VK_S );
//              select_item.addActionListener( item_listener );
//    JMenuItem clear_item = new JMenuItem( MENU_CLEAR );
//              //clear_item.setMnemonic( KeyEvent.VK_BACK_SPACE );
//              clear_item.addActionListener( item_listener );
//    JMenuItem clear_all_item = new JMenuItem( MENU_CLEAR_ALL );
//              //clear_all_item.setMnemonic( KeyEvent.VK_S );
//              clear_all_item.addActionListener( item_listener );
    JMenuItem delete_item = new JMenuItem( MENU_DELETE );
              //delete_item.setMnemonic( KeyEvent.VK_X );
              delete_item.addActionListener( item_listener );
    JPopupMenu popup_menu = new JPopupMenu( "SingleDataSetPopupMenu" );
//               popup_menu.add( clear_item );
//               popup_menu.add( clear_all_item );
               popup_menu.add( delete_item );
               popup_menu.add( ops_popup_menu );
               popup_menu.show(  e.getComponent(), e.getX(), e.getY()  );
  }


  /**
   *
   */
  public void MultipleDataSetPopupMenu( TreePath[] tp, MouseEvent e )
  {
    System.out.println( "MultipleDataSetPopupMenu(...)" );
  }


  /**
   *
   */
  public void pointAtNode( TreePath[] tp )
  {
    DataSet _ds = traverseUpToDataSet( tp[0] );

    DefaultMutableTreeNode dmtn = null;
    dmtn = (DefaultMutableTreeNode)(  tp[0].getLastPathComponent()  );

    if(  dmtn.getUserObject() instanceof Data  )
    {
      _ds.setPointedAtIndex(  _ds.getIndex_of_data( (Data)dmtn.getUserObject() )  );
      _ds.notifyIObservers( IObserver.POINTED_AT_CHANGED );
    }
  }


  /**
   * sets newly selected Data as selected and notifies their containing
   * DataSet.
   */
  public void selectNode( TreePath[] tp )
  {
    DefaultMutableTreeNode dmtn = null;

    //
    //we can only deal w/ selections from one DataSet at a time,
    //so we'll arbitrarily choose the DataSet that the first
    //selection corresponds to
    //
    DataSet ds = traverseUpToDataSet( tp[0] );
    if(  ds != null  )
    {
      for( int i=0;  i<tp.length;  i++ )
      {
        dmtn = (DefaultMutableTreeNode)(  tp[i].getLastPathComponent()  );
        if( dmtn != null  &&  
            ds.equals(  traverseUpToDataSet(tp[i]) ) &&
            dmtn.getUserObject() instanceof Data  )
        {
          Data d = (Data)dmtn.getUserObject();
          if(  d.isSelected() == false   )
            d.setSelected( true );
          else
            d.setSelected( false );
        }
        else if(  dmtn.getUserObject() != null  )
          System.out.println(  "non-Data: " + dmtn.getUserObject().toString()  );
        
      }
      ds.notifyIObservers( IObserver.SELECTION_CHANGED );
    }
    else
      return;
  }


  /**
   * recursivly find the DataSet that this Data block
   * belongs to and return it the caller
   */
  protected DataSet traverseUpToDataSet( TreePath tp )
  {
    DefaultMutableTreeNode dmtn = (DefaultMutableTreeNode)(  tp.getLastPathComponent()  );

    //terminal case(s)
    if(  tp.getParentPath() == null  )
      return null;
    else if(  dmtn.getUserObject() instanceof DataSet  )
      return (DataSet)dmtn.getUserObject();

    //reCURSE!
    else
      return traverseUpToDataSet(  tp.getParentPath()  );
  }

}

