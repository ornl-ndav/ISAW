/* Generated By:JavaCC: Do not edit this line. ParameterGUIParser.java */
package Command.JavaCC;

import java.io.StringReader;

import java.util.*;

public class ParameterGUIParser implements ParameterGUIParserConstants {
  //don't want to continually recreate this thing
  private static ParameterGUIParser myParser;
  private static boolean expandVectorIntoElements = true;
  private static boolean standalone = false;

  /**
   * Method used to run the ParameterGUIParser for testing purposes.
   *
   * @param args Unused.
   *
   * @throws ParseException If anything goes wrong during parsing
   */
  public static void main( String args[] ) throws ParseException {
    standalone = true;
    myParser = new ParameterGUIParser( System.in );
    myParser.ExpansionList(  );
  }

  /**
   *  Used to call the parser from an outside class.
   *
   * @param text The text to parse.
   *
   * @return The result of the parsing.
   *
   * @throws ParseException If anything goes wrong during parsing
   */
  public static Vector parseText( String text ) throws ParseException {
    standalone = false;
    //need a semicolon on the end
    if( text.indexOf( ";" ) < 0 ) {
      text = text.trim(  ) + ";";
    }
    if( myParser == null ) {
      myParser = new ParameterGUIParser( new StringReader( text )  );
    } else {
      myParser.ReInit( new StringReader( text )  );
    }
    Vector tempy = myParser.ExpansionList(  );

    if( tempy.size(  ) == 1 && tempy.get( 0 ).equals( "" ) ) {
      return new Vector(  );
    }  else  {
      return tempy;
    }
  }


  /**
   * Used to expand an integer list (e.g. 5:8 to 5,6,7,8).
   *
   * @param first The first integer in the list.
   * @param last The last integer in the list.
   * @param step The step size.
   *
   * @throws ParseException if the list cannot be created due to integer
   * wraparound (e.g. 60:10:10 will not work since it has to wrap around to get
   * to 10 from 60 going forwards).
   */
  private static Vector expandIntList( int first, int last, int step ) throws
                 ParseException {
    Vector intExpansion = new Vector(  );

    intExpansion.add( new Integer( first ) );

    //forward expansion
    if( first <= last ) {
      if( step > 0  ) {
        //positive step size
        for( int i = first + step; i <= last; i += step ) {
          intExpansion.add( new Integer( i ) );
        }
      } else {
        //we would have to wrap around to expand the list
        throw new ParseException(
          "Cannot expand " + first + ":" + last + ":" + step + "due to integer wraparound." );
      }
    } else {
      //backward expansion
      if( step < 0 ) {
        for( int i = first + step; i >= last; i += step ) {
          intExpansion.add( new Integer( i ) );
        }
      } else {
        //we would have to wrap around to expand the list
        throw new ParseException(
          "Cannot expand " + first + ":" + last + ":" + step + "due to integer wraparound." );
      }
    }
    return intExpansion;
  }

  static final public Vector ExpansionList() throws ParseException {
  Vector expandedList = null;
    if( standalone ) {
      System.out.println( "Please type in an expression with or without " +
        " brackets, (e.g. [5:8], [5,6,7], [\"john\"]. 5:10:2) or ^D to quit:\n" );
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
      case VARIABLE:
      case WINDOWS_PATH:
      case UNIX_PATH:
      case STRING:
      case COLON_PAIR:
      case STEPPED_COLON_PAIR:
      case FLOATING_POINT:
      case EMPTY_ARRAY:
      case 23:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      expandedList = Expansion();
      jj_consume_token(21);
      //a semicolon ends the expansion
      //print the parsed expression
      if( standalone ) {
        System.out.println( expandedList );
        System.out.println(  );
        System.out.println( "Please type in another expression in brackets or ^D to quit:" );
        System.out.println(  );
      }
    }
    {if (true) return expandedList;}
    jj_consume_token(0);
    throw new Error("Missing return statement in function");
  }

  static final public Vector Expansion() throws ParseException {
  Vector tempArray = new Vector(  );
  Object element, listElem;
    element = toArray();
    if( element instanceof Collection && expandVectorIntoElements ) {
        //when we get a Vector back (such as as for an int expansion) add the
        //elements themselves if we are told to expand the elements
        tempArray.addAll( ( Collection)element );
    } else {
      tempArray.add( element );
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
      case 22:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 22:
        jj_consume_token(22);
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WHITESPACE:
            ;
            break;
          default:
            jj_la1[2] = jj_gen;
            break label_3;
          }
          jj_consume_token(WHITESPACE);
        }
        break;
      case WHITESPACE:
        label_4:
        while (true) {
          jj_consume_token(WHITESPACE);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WHITESPACE:
            ;
            break;
          default:
            jj_la1[3] = jj_gen;
            break label_4;
          }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 22:
          jj_consume_token(22);
          label_5:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WHITESPACE:
              ;
              break;
            default:
              jj_la1[4] = jj_gen;
              break label_5;
            }
            jj_consume_token(WHITESPACE);
          }
          break;
        default:
          jj_la1[5] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      element = toArray();
      //could have any number of comma separated tokens, or multiple space
      //separated tokens.  Treat any and all spaces as delimiters (except
      //inside quotes of course)
    if( element instanceof Collection && expandVectorIntoElements ) {
      tempArray.addAll( ( Collection )element );
    } else {
      tempArray.add( element );
    }
    }
    //if we only have one element and it is a Vector, expand the inner Vector
    if( tempArray.size(  ) == 1 &&
        tempArray.firstElement(  ) instanceof Vector ) {
      tempArray = ( Vector )( tempArray.firstElement(  ) );
    }
    {if (true) return tempArray;}
    throw new Error("Missing return statement in function");
  }

  static final public Object toArray() throws ParseException {
  Token t;
  String expansion;
  Object recursedElement;
  int index, first, last;
  //reset for every element iteration
  expandVectorIntoElements = true;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGIT:
      //matched a digit
        t = jj_consume_token(DIGIT);
    {if (true) return Integer.valueOf( t.image );}
      break;
    case FLOATING_POINT:
      //matched a float
        t = jj_consume_token(FLOATING_POINT);
    {if (true) return Double.valueOf( t.image );}
      break;
    case STRING:
      //matched a String
        t = jj_consume_token(STRING);
    t.image = t.image.substring( 1, t.image.length(  ) - 1 );
    {if (true) return t.image;}
      break;
    case VARIABLE:
      //matched a variable
        t = jj_consume_token(VARIABLE);
    //at some point, we should add support for things like "ISAWDS1"

    {if (true) return t.image;}
      break;
    case 23:
      jj_consume_token(23);
      recursedElement = Expansion();
      jj_consume_token(24);
    //tell the outside program to NOT expand this Vector
    expandVectorIntoElements = false;
    {if (true) return recursedElement;}
      break;
    case COLON_PAIR:
      //matched a colon pair (e.g. 5:8)
        t = jj_consume_token(COLON_PAIR);
    expansion = t.image.trim(  );
    index = expansion.indexOf( ":" );
    first = Integer.parseInt( expansion.substring( 0, index ) );
    first = Integer.parseInt( expansion.substring( 0, index ) );
    last = Integer.parseInt( expansion.substring( index + 1,
                             expansion.length(  ) ) );
    if( first <= last ) {
      {if (true) return expandIntList( first, last, 1 );}
    } else {
      {if (true) return expandIntList( first, last, -1 );}
    }
      break;
    case STEPPED_COLON_PAIR:
      //matched a stepped colon pair(e.g. 10:35:2)
        t = jj_consume_token(STEPPED_COLON_PAIR);
    expansion = t.image.trim(  );
    index = expansion.indexOf( ":" );
    first = Integer.parseInt( expansion.substring( 0, index ) );
    //trim out the first colon to find the step size
    expansion = expansion.substring( index + 1, expansion.length(  ) );
    index = expansion.indexOf( ":" );
    last = Integer.parseInt( expansion.substring( 0, index ) );
    int step = Integer.parseInt( expansion.substring( index + 1,
                                 expansion.length(  ) ) );

    {if (true) return expandIntList( first, last, step );}
      break;
    case EMPTY_ARRAY:
      //someone did not add anything to the array, so return an empty String
        t = jj_consume_token(EMPTY_ARRAY);
    {if (true) return "";}
      break;
    case WINDOWS_PATH:
      //windows path.  
        t = jj_consume_token(WINDOWS_PATH);
    /*if( !t.image.startsWith( "\"" ) ) {
      t.image = t.image.substring( 1, t.image.length(  ) );
    }
    if( !t.image.endsWith( "\"" ) ) {
      t.image = t.image.substring( 0, t.image.length(  ) - 1);
    }*/

    {if (true) return t.image;}
      break;
    case UNIX_PATH:
      //unix path.  
        t = jj_consume_token(UNIX_PATH);
    /*if( !t.image.startsWith( "\"" ) ) {
      t.image = t.image.substring( 1, t.image.length(  ) );
    }
    if( !t.image.endsWith( "\"" ) ) {
      t.image = t.image.substring( 0, t.image.length(  ) - 1);
    }*/

    {if (true) return t.image;}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  static public ParameterGUIParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  static public Token token, jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[8];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x9f1c08,0x400020,0x20,0x20,0x20,0x400000,0x400020,0x9f1c08,};
   }

  public ParameterGUIParser(java.io.InputStream stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParameterGUIParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  public ParameterGUIParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParameterGUIParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  public ParameterGUIParser(ParameterGUIParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  public void ReInit(ParameterGUIParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  static final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.Vector jj_expentries = new java.util.Vector();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  static public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[25];
    for (int i = 0; i < 25; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 8; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 25; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  static final public void enable_tracing() {
  }

  static final public void disable_tracing() {
  }

}
