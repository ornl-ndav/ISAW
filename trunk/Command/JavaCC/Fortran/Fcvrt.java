/* Generated By:JavaCC: Do not edit this line. Fcvrt.java */
/*
 * File:  Fcvrt.java 
 *             
 * Copyright (C) 2004, Ruth Mikkelson
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
 *
 * Contact : Ruth Mikkelson <mikkelsonr@uwstout.edu>
 *           Department of Mathematics, Statistics and Computer Science
 *           University of Wisconsin-Stout
 *           Menomonie, WI 54751, USA
 *
 * This work was supported by the Intense Pulsed Neutron Source Division
 * of Argonne National Laboratory, Argonne, IL 60439-4845, USA.
 * This work was supported by the National Science Foundation under
 * grant number DMR-0218882
 *
 * For further information, see <http://www.pns.anl.gov/ISAW/>
 *
 * This java file was created from the file FortJ2.jj using JavaCC. See header
 * for information
 * Modified:
 *
 * $Log$
 * Revision 1.4  2004/06/22 15:42:09  rmikk
 * Result of update Fort2j.jj
 *
 */

 package Command.JavaCC.Fortran;
 import java.util.*;
 import Command.JavaCC.Fortran.*;
 /**
   *  Constructor
   *  The main method invokes the specialized FortranTokenManager. 
   */
public class Fcvrt implements FcvrtConstants {
   private static final int indentDelta = 2;
   ListHandler Variable=new ListHandler();
   String CurrentMethodName = null;
   int mode =0;   //0 start,1-sub/fxn line,2-declarations,3-statements,4-END->0
   boolean lastStatementSimple = true;
   String doLabels=";";
   String Parameters=";";
   boolean threwException = false;
   int thrVarnum=0;
   public String filename = null;
   boolean Finished = false;
   int indent =2;
   String buff = null;
   public String Res ="";
  /**
    *  Program that invokes this translator.
    * @param  args[0]  the filename of a file that contains a [sequence of]
    *                  subroutine[s] or function[s]
    * @return nothing but each subroutine and function will be translated
    *          to a different java file. The filename corresponds to the 
    *          subroutine or function name.
    */
  public static void main( String args[]){
      Fcvrt parser;


      parser = new Fcvrt(new FortranTokenManager(args[0]));
      try{
         parser.filename = new java.io.File(args[0]).getCanonicalPath();
      }catch(Exception s3){
         parser.filename ="/x.f";
      }

    try {


      System.out.println("Result=\n"+parser.start());
      System.out.println("Java Parser Version 1.0.2:  Java program parsed successfully.");

    } catch (ParseException e) {
      System.out.println("ERROR REsult so far is \n"+parser.Res);
      System.out.println("Java Parser Version 1.0.2:  Encountered errors during parse."+
       e.toString());
      e.printStackTrace();

    }
  }

  /**
    *  All assignment statements go through this routine
    *  @param  varname  the variable name
    *  @param A list of parameters in String form
    *  @param expression the String form of an expression to be assigned to
    *                    the variable 
    * @return a String representing the Java form of the statement
    */
  private String makeUpAssignmentStatement( String varname, String[] params,
                                                    String expression) throws ParseException
                   {
    String s=varname;
    if( varname.equals( CurrentMethodName))
       s +="result";

    if( params !=null)
      if(params.length >0){
         if( !checkVariable( varname, params.length))
           throw new ParseException("Arrays must be declared before assignment");
         for(int i=0;i<params.length;i++){
           s += "[(int)("+params[i]+"-"+Offset(varname,i)+")]";
         }
      }
    if( !checkVariable( varname, -1))
       addVariable( varname, "DIMENSION",2, params);
    VariableInfo vbInf = (VariableInfo)Variable.get( varname);
    String dt = vbInf.DataType;
    if( dt == null) dt = "XX";
    if( dt.length()<1) dt ="XX";
    if( "int;float;long;byte;String;double;".indexOf(dt)<0)
      if( "IJKLMNO".indexOf( varname.toUpperCase().charAt(0))>=0)
         dt = "int";
      else
         dt = "float";

    return s+= "=("+dt+")"+expression+";\n";
   }
  /**
    *  @param name  the variable name
    *  @param DataType the data type of the variable(null,int,float, etc)
    *  @param location  0-common;1-parameter;2-local,3-external fxn
    *  @param Parameters  The list of parameters in string form
    */
  private void addVariable( String name, String DataType,int location,
                   String[]Parameters){
     VariableInfo vbInf = (VariableInfo) Variable.get(name);
     if( vbInf == null)
        Variable.add(new VariableInfo( DataType, location,Parameters),name);
     else{
        if( vbInf.location < 0)
           vbInf.location = location;
        if(location > 2)
           vbInf.location = location; //External a
        if( vbInf.DataType == null)
            vbInf.DataType = DataType;
        if( ";int;float;double;long;short;".indexOf(";"+vbInf.DataType+";")<0)
            vbInf.DataType=DataType;
        if( vbInf.Parameters == null)
            vbInf.Parameters =Parameters;

     }

  }
  /**
    *  @param name is the possible variable name
    *  @numParameters  the number of dimensions the variable has, 0 and -1 OK
    *  @return the data type of the variable(0-int,1-float,2 -Double, -1 implicit
    */
  private boolean checkVariable( String name, int numParameters){
     VariableInfo vinf= (VariableInfo)Variable.get( name);
     if( vinf == null)
        return false;
     if( numParameters < 0)
        return true;
     if( vinf.Parameters == null)
        if( numParameters == 0)
           return true;
        else
           return false;
     if( vinf.Parameters.length == numParameters)
        return true;
     return false;

  }
  private void SetDataTypes( ListHandler VarList){
     for( int i=0; i< VarList.size(); i++){
        VariableInfo vbInf =(VariableInfo)VarList.getValue(i);
        if( vbInf.location < 0)
             vbInf.location = 2;
        if( ";int;float;double;long;short;byte;boolean;String;".indexOf(
                   ";"+vbInf.DataType+";")<0){

           String name = VarList.getName(i).toUpperCase();
           if( "IJKLMNO".indexOf(name.charAt(0))<0)
             vbInf.DataType ="float";
           else
             vbInf.DataType = "int";

        }

     }


  }

 private String Offset( String ArrayVarName, int dim){

    VariableInfo vbInf =(VariableInfo)Variable.get( ArrayVarName);
    if( vbInf == null)
      return "0";
    if( vbInf.Parameters == null)
       return "0";
    if( dim < 0)
       return "0";
    if( dim >= vbInf.Parameters.length)
       return "0";
    //if( vbInf.location ==1)
    //   return "0";
    String S = vbInf.Parameters[dim];
    if( S.indexOf(':') < 0)
       return "1";
    return S.substring(0,S.indexOf(':'));

 }
 public String getDefaultInitValue(String DataType,String[] Parameters)
             throws ParseException{
   if( Parameters != null)
       if( Parameters.length > 0)
          return "null";
   if( DataType.equals("String"))
      return "null";
   if( DataType.equals("int"))
      return "0";
   else if( DataType.equals("float"))
      return "0f";
   else if( DataType.equals("double"))
      return "0.0";
   else if( DataType.equals("long"))
      return "(long)0";
   else if( DataType.equals("short"))
      return "(short)0";
   else if( DataType.equals("byte"))
      return "(byte)0";
   else if( DataType.equals("boolean"))
      return "true";
   else
     throw new ParseException( DataType+" is not supported");
 }

 private String Pretty( int indentLevel, String S){
   if( S == null)
      return "";
   if( S.trim().length()<1)
      return "";
   String Res ="";
   if( buff == null){
     char[] buff1 = new char[indentDelta];
     Arrays.fill( buff1,' ');
     buff= new String( buff1);
   }
   for(int i=0;i<indentLevel; i++)
     Res +=buff;
   int i = S.indexOf("\n");
   if( i >=0)
     if( Res.length() +i < 80)
        return Res + S.substring(0,i+1)+ Pretty(indentLevel+1,S.substring(i+1));

    int j = -1;
    boolean quotemode = false;
    for( int k = 0; (k < S.length())&&(k+Res.length()<80);  k++)
       if( "\"+-*/^()[]=".indexOf(S.charAt( k))>=0)
          if( S.charAt(k) =='\"')
             quotemode = !quotemode;
          else if( quotemode){}
          else if( k ==S.length()-1)
            j=k;
          else if("+-*/=".indexOf(S.charAt(k+1))> 0)
            {}
           else
              j = k;
    if( j < 0)
       return Res +S;
    return Res + S.substring(0,j+1)+"\n"+Pretty(indentLevel+1, S.substring(j+1));
 }

  final public String start() throws ParseException {
   String s1="";
         // s2="";
   Token t=null;
   String errStart,
         errEnd;
   int oldIndentLevel = indent;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMENT:
      case EOLN:
      case LABEL:
      case SUBROUTINE:
      case FUNCTION:
      case INTEGER:
      case REAL:
      case CHARACTER:
      case LOGICAL:
      case EXTERNAL:
      case DIMENSION:
      case CONTINUE:
      case ELSE:
      case ENDIF:
      case IF:
      case ELSEIF:
      case DO:
      case CALL:
      case END:
      case RETURN:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMENT:
        t = jj_consume_token(COMMENT);
        jj_consume_token(EOLN);
     Res+= "//"+t.image+"\n";
        break;
      case LABEL:
        t = jj_consume_token(LABEL);
        s1 = statement(Res);
        errStart ="";
       errEnd ="";
       if(threwException){
          errStart ="try{\n";
          errEnd = "}catch(Throwable Thrvar"+thrVarnum+"){\n";
          errEnd += "  return new ErrorString( Thrvar"+thrVarnum+");\n}\n";
          threwException = false;
          thrVarnum++;
          Res += Pretty( oldIndentLevel, errStart);
          Res += Pretty(oldIndentLevel+1, s1+"\n");
          Res += Pretty( oldIndentLevel, errEnd);

       }
       else
          Res += Pretty(oldIndentLevel,errStart+s1+"\n"+errEnd);
       if( lastStatementSimple){
       String lbl = t.image.trim();
       for( int k= doLabels.indexOf(";"+lbl+";");k>=0;
            k= doLabels.indexOf(";"+lbl+";",k+2)){
            Res += "}\n";
            indent--;
       }

       //Res+= Pretty(oldIndentLevel,errStart+s1+"\n"+errEnd);
       oldIndentLevel = indent;
       if( Finished)
          {if (true) return Res;}
       }
        break;
      case EOLN:
      case SUBROUTINE:
      case FUNCTION:
      case INTEGER:
      case REAL:
      case CHARACTER:
      case LOGICAL:
      case EXTERNAL:
      case DIMENSION:
      case CONTINUE:
      case ELSE:
      case ENDIF:
      case IF:
      case ELSEIF:
      case DO:
      case CALL:
      case END:
      case RETURN:
      case IDENTIFIER:
        s1 = statement(Res);
       errStart ="";
      errEnd ="";
       if(threwException){
          errStart ="try{\n";
          errEnd = "}catch(Throwable Thrvar"+thrVarnum+"){\n";
          errEnd += "  return new ErrorString( Thrvar"+thrVarnum+");\n}\n";
          threwException = false;
          thrVarnum++;

          Res += Pretty( oldIndentLevel, errStart);
          Res += Pretty(oldIndentLevel+1, s1+"\n");
          Res += Pretty( oldIndentLevel, errEnd);

       }
      else
          Res+= Pretty(oldIndentLevel,errStart+s1+errEnd);
       oldIndentLevel = indent;
      if( Finished)
        {if (true) return Res;}
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
    {if (true) return Res;}
    throw new Error("Missing return statement in function");
  }

  final public String statement(String Res) throws ParseException {
String s1;//s2="",s3="";
String[] params = null;
Token t;
 //String[] ss=null;

  lastStatementSimple = true;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUBROUTINE:
      jj_consume_token(SUBROUTINE);
      s1 = RestofMethod("SUROUTINE");
      jj_consume_token(EOLN);
       {if (true) return s1;}
      break;
    case FUNCTION:
      jj_consume_token(FUNCTION);
      s1 = RestofMethod("FUNCTION");
      jj_consume_token(EOLN);
       {if (true) return s1;}
      break;
    case INTEGER:
      jj_consume_token(INTEGER);
      s1 = RestofDeclare("int");
      jj_consume_token(EOLN);
       {if (true) return s1;}
      break;
    case REAL:
      jj_consume_token(REAL);
      s1 = RestofDeclare("float");
      jj_consume_token(EOLN);
       {if (true) return s1;}
      break;
    case CHARACTER:
      jj_consume_token(CHARACTER);
      s1 = RestofDeclare("String");
      jj_consume_token(EOLN);
       {if (true) return s1;}
      break;
    case LOGICAL:
      jj_consume_token(LOGICAL);
      s1 = RestofDeclare("boolean");
      jj_consume_token(EOLN);
       {if (true) return s1;}
      break;
    case EXTERNAL:
      jj_consume_token(EXTERNAL);
      s1 = RestofExternal();
      jj_consume_token(EOLN);
       {if (true) return s1;}
      break;
    case DIMENSION:
      jj_consume_token(DIMENSION);
      s1 = RestofDeclare("");
      jj_consume_token(EOLN);
       {if (true) return s1;}
      break;
    case CONTINUE:
      jj_consume_token(CONTINUE);
      s1 = RestofExpression("CONTINUE");
       {if (true) return s1;}
      break;
    case ELSE:
      jj_consume_token(ELSE);
      s1 = RestofExpression("ELSE");
       {if (true) return s1;}
      break;
    case ENDIF:
      jj_consume_token(ENDIF);
      s1 = RestofExpression("ENDIF");
       {if (true) return s1;}
      break;
    case IF:
      jj_consume_token(IF);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
      s1 = RestofIf(0, params);
        {if (true) return s1;}
      break;
    case ELSEIF:
      jj_consume_token(ELSEIF);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      s1 = RestofIf(1,params);
       if( !lastStatementSimple)
              {if (true) return  "}else "+s1+"\n";}
       else
         {if (true) return s1;}
      break;
    case EOLN:
      jj_consume_token(EOLN);
      {if (true) return "\n";}
      break;
    case DO:
      jj_consume_token(DO);
      s1 = RestofDo();
      jj_consume_token(EOLN);
       {if (true) return s1;}
      break;
    case CALL:
      jj_consume_token(CALL);
      s1 = RestofCall();
      jj_consume_token(EOLN);
        {if (true) return s1;}
      break;
    case END:
      jj_consume_token(END);
      s1 = RestofEnd(Res ,"END");
       {if (true) return s1;}
      break;
    case RETURN:
      jj_consume_token(RETURN);
      s1 = RestofReturn();
      {if (true) return s1;}
      break;
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      jj_consume_token(EQUALS);
      s1 = Expression("");
      jj_consume_token(EOLN);
          if( mode <1)  {if (true) throw new ParseException("Cannot have a statement outside of a sub");}
          mode = 3;
         if(params != null)
           if( !checkVariable(t.image.toUpperCase(),params.length))
              {if (true) throw new ParseException("Cannot assign value to function");}
         if( !checkVariable( t.image.toUpperCase(),-1))
              addVariable(t.image.toUpperCase(),"",2,null);
         {if (true) return makeUpAssignmentStatement(t.image.toUpperCase() , params , s1);}
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String RestofMethod(String name) throws ParseException {
  String s;//s2,s1=null;
  String[] params=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
    case LPAREN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      jj_consume_token(EQUALS);
      s = Expression("");
          if( mode <1)  {if (true) throw new ParseException("Cannot have a statement outside of a sub");}
          mode = 3;
         {if (true) return makeUpAssignmentStatement(name , params , s);}
      break;
    case SUBROUTINE:
    case FUNCTION:
    case INTEGER:
    case REAL:
    case CHARACTER:
    case LOGICAL:
    case EXTERNAL:
    case DIMENSION:
    case CONTINUE:
    case ELSE:
    case ENDIF:
    case IF:
    case DO:
    case CALL:
    case RETURN:
    case IDENTIFIER:
    case THEN:
    case TRUE:
    case FALSE:
    case EXP:
    case WRITE:
    case READ:
    case WHILE:
      s = PossVarName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
        if( mode >1) {if (true) throw new ParseException("Cannot have a sub/Funct line inside a body");}
        mode = 2;
        CurrentMethodName = s.toUpperCase();
        if(name.equals("FUNCTION"))
            addVariable(CurrentMethodName,"DIMENSION",1, null);
        if(params != null)
          for( int i=0; i<params.length;i++){
             while( params[i].startsWith("("))
               params[i]=params[i].substring(1);

             while( params[i].endsWith(")"))
               params[i]=params[i].substring(0,params[i].length()-1);
             addVariable( params[i], "dimension",1,null);
             Parameters +=params[i]+";";
          }
        {if (true) return  "";}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/** Follows Declaration lines 
*/
  final public String RestofDeclare(String name) throws ParseException {
 //Token t1=null,t2=null; 
 String s,s1=null,s2=null,s3="";

 //int ndims = -1;
 String[] params=null,params1=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
    case LPAREN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      jj_consume_token(EQUALS);
      s = Expression("");
          if( mode <1)  {if (true) throw new ParseException("Cannot have a statement outside of a sub");}
          mode = 3;
          if( params != null)
            if( !checkVariable( name,params.length))
               {if (true) throw new ParseException("Array Variable "+name+" is not correctly declared");}
            else{}
          else
             addVariable( name.toUpperCase(),"DIMENSION",-1,params);
          if( name.equals("int") )
             {if (true) return makeUpAssignmentStatement("INTEGER", params, s);}
          else if( name.equals("float"))
             {if (true) return makeUpAssignmentStatement("REAL", params, s);}
          else if( name.equals("boolean"))
             {if (true) return makeUpAssignmentStatement("LOGICAL", params, s);}
          else
             {if (true) return makeUpAssignmentStatement("DIMENSION", params, s);}
      break;
    case SUBROUTINE:
    case FUNCTION:
    case INTEGER:
    case REAL:
    case CHARACTER:
    case LOGICAL:
    case EXTERNAL:
    case DIMENSION:
    case CONTINUE:
    case ELSE:
    case ENDIF:
    case IF:
    case DO:
    case CALL:
    case RETURN:
    case IDENTIFIER:
    case THEN:
    case TRUE:
    case FALSE:
    case EXP:
    case WRITE:
    case READ:
    case WHILE:
      s1 = PossVarName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUBROUTINE:
      case FUNCTION:
      case INTEGER:
      case REAL:
      case CHARACTER:
      case LOGICAL:
      case EXTERNAL:
      case DIMENSION:
      case CONTINUE:
      case ELSE:
      case ENDIF:
      case IF:
      case DO:
      case CALL:
      case RETURN:
      case IDENTIFIER:
      case THEN:
      case TRUE:
      case FALSE:
      case EXP:
      case WRITE:
      case READ:
      case WHILE:
        s2 = PossVarName();
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ArgList();
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        s3 = PossVarName();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          params1 = ArgList();
          break;
        default:
          jj_la1[13] = jj_gen;
          ;
        }
            if( checkVariable( s3,-1))
               addVariable(s3,name,-1,params1);
            else
               addVariable( s3,name,2,params1);
            params1 = null;
      }
          if( s2 == null){
          if( mode >2) {if (true) throw new ParseException("Cannot declare after statements");}
          mode = 2;
          addVariable(s1,name,-1,params);
          {if (true) return "";}
         }
         if( !s1.equals("FUNCTION"))
            {if (true) throw new ParseException(" Must Be a function here");}
         addVariable( s2.toUpperCase(), name,2, null);
         CurrentMethodName = s2.toUpperCase();

         if( params != null)
          if( params.length >0)
         for( int i = 0; i< params.length; i++){
             while( params[i].startsWith("("))
               params[i]=params[i].substring(1);

             while( params[i].endsWith(")"))
               params[i]=params[i].substring(0,params[i].length()-1);
             addVariable( params[i], "dimension",1,null);
             Parameters += params[i]+";";
          }
          {if (true) return "";}
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String RestofExternal() throws ParseException {
 //Token t1=null,t2=null;
 String s,s1=null,s3="";//s2="";
 //String Res="";
 String[] params=null;//params1=null; 
 VariableInfo vbInf;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
    case LPAREN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      jj_consume_token(EQUALS);
      s = Expression("");
          if( mode <1)  {if (true) throw new ParseException("Cannot have a statement outside of a sub");}
          mode = 3;

          {if (true) return makeUpAssignmentStatement("EXTERNAL", params, s);}
      break;
    case SUBROUTINE:
    case FUNCTION:
    case INTEGER:
    case REAL:
    case CHARACTER:
    case LOGICAL:
    case EXTERNAL:
    case DIMENSION:
    case CONTINUE:
    case ELSE:
    case ENDIF:
    case IF:
    case DO:
    case CALL:
    case RETURN:
    case IDENTIFIER:
    case THEN:
    case TRUE:
    case FALSE:
    case EXP:
    case WRITE:
    case READ:
    case WHILE:
      s1 = PossVarName();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_3;
        }
        jj_consume_token(COMMA);
        s3 = PossVarName();
          vbInf = (VariableInfo) Variable.get(s3);
          if( vbInf == null)
             Variable.add(new VariableInfo( "DIMENSION", 3,null),s3);
          else
             vbInf.location = 3;
      }
         vbInf = (VariableInfo) Variable.get(s1);
          if( vbInf == null)
             Variable.add(new VariableInfo( "DIMENSION", 3,null),s1);
          else
             vbInf.location = 3;
          {if (true) return "";}
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
  * This one must consume <EOLN>. Used only for CONTINUE, ELSE, and ENDIF
  */
  final public String RestofExpression(String vname) throws ParseException {
//Token t1=null,t2=null;
 String s;//s1=null,s2="",s3="";
// String Res="";
 String[] params=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
    case LPAREN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      jj_consume_token(EQUALS);
      s = Expression("");
      jj_consume_token(EOLN);
          if( mode <1)  {if (true) throw new ParseException("Cannot have a statement outside of a sub");}
          mode = 3;
          {if (true) return makeUpAssignmentStatement(vname, params, s);}
      break;
    case EOLN:
      jj_consume_token(EOLN);
         vname = vname.toUpperCase();
         if( vname.equals("CONTINUE"))
             {if (true) return "\n";}
         else if( vname.equals("ELSE"))
             {if (true) return "} else {\n";}
         else if( vname.equals("ENDIF")){
              indent--;
              {if (true) return "}\n";}
         }
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
  *
  *@param mode  0 if any if, 1 if struct if or 2 if one-line if
  */
  final public String RestofIf(int Ifmode, String[] params) throws ParseException {
  String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
      jj_consume_token(EQUALS);
      s = Expression("");
      jj_consume_token(EOLN);
          if( mode <1)  {if (true) throw new ParseException("Cannot have a statement outside of a sub");}
          mode = 3;
          {if (true) return makeUpAssignmentStatement("IF", params, s);}
      break;
    case THEN:
      jj_consume_token(THEN);
      s = RestofThen(params,Ifmode);
         {if (true) return s;}
      break;
    case EOLN:
    case SUBROUTINE:
    case FUNCTION:
    case INTEGER:
    case REAL:
    case CHARACTER:
    case LOGICAL:
    case EXTERNAL:
    case DIMENSION:
    case CONTINUE:
    case ELSE:
    case ENDIF:
    case IF:
    case ELSEIF:
    case DO:
    case CALL:
    case END:
    case RETURN:
    case IDENTIFIER:
      s = statement("");
       if(! lastStatementSimple)
          {if (true) throw new ParseException("1 line if's must be followed by simple statments");}
       if(params == null)
            {if (true) throw new ParseException("Cannot have empty conditional statement");}
       if( params.length != 1)
           {if (true) throw new ParseException("only one Conditional statement allowed");}
       if( mode <1)
           {if (true) throw new ParseException("Cannot have a statement outside of a sub");}

       lastStatementSimple = true;
       {if (true) return "if(" + params[0]+")\n   "+s+"\n";}
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String RestofThen(String[] params,int Ifmode) throws ParseException {
  String[] params1= null;
  String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EOLN:
      jj_consume_token(EOLN);
         if(params == null)
           {if (true) throw new ParseException("Cannot have empty conditional statement");}
         if( params.length != 1)
           {if (true) throw new ParseException("only one Conditional statement allowed");}
         if( mode <1)
                {if (true) throw new ParseException("Cannot have a statement outside of a sub");}
         if( Ifmode >1)
              {if (true) throw new ParseException("Structured if statement not allowed");}
         lastStatementSimple = false;
         indent++;
         {if (true) return "if("+params[0]+"){\n";}
      break;
    case EQUALS:
    case LPAREN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params1 = ExpressionList();
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      jj_consume_token(EQUALS);
      s = Expression("");
      jj_consume_token(EOLN);
         if(params == null)
           {if (true) throw new ParseException("Cannot have empty conditional statement");}
         if( params.length != 1)
           {if (true) throw new ParseException("only one Conditional statement allowed");}
         if( mode <1)
                {if (true) throw new ParseException("Cannot have a statement outside of a sub");}
         if( Ifmode >1)
              {if (true) throw new ParseException("Structured if statement not allowed");}
         {if (true) return "if("+params[0]+")\n"+
                       makeUpAssignmentStatement("THEN",params1, s);}
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String RestofDo() throws ParseException {
 Token t;
 String s,s1;//s2,s3=null,;
 String[] params = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
    case LPAREN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
      jj_consume_token(EQUALS);
      s = Expression("");
          if( mode <1)  {if (true) throw new ParseException("Cannot have a statement outside of a sub");}
          mode = 3;
          {if (true) return makeUpAssignmentStatement("DO", params, s);}
      break;
    case INTNUM:
      t = jj_consume_token(INTNUM);
      s = PossVarName();
      s1 = RestofDoLabel(s);
       doLabels += t.image.trim()+";";
       indent++;
       {if (true) return s1;}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String RestofDoLabel(String s) throws ParseException {
  String s1,s2,s3=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
      jj_consume_token(EQUALS);
      s1 = Expression("");
      jj_consume_token(COMMA);
      s2 = Expression("");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        s3 = Expression("");
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
     if( s3 == null)
         s3 = "1";

     if(!checkVariable(s,-1))
        addVariable( s, "DIMENSION",2, null);

     VariableInfo vbInf = (VariableInfo)Variable.get(s);
     String dt = vbInf.DataType;
     if(dt == null)
       dt ="XX";
     else if( dt.length()<1)
       dt ="XX";
     if( "int;float;String;boolean;byte;".indexOf(dt) <0)
       if( "IJKLMNO".indexOf( s.toUpperCase().charAt(0))>=0)
          dt = "int";
       else
          dt = "float";
     {if (true) return "for("+s+"=("+dt+")"+s1+";util.Sign("+s3+")*"+s+
               "<="+"util.Sign("+s3+")*"+s2+";"+s+"+=("+dt+")"+s3+"){\n";}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      s1 = Expression("");
      jj_consume_token(RPAREN);
     if( !s.equals("WHILE"))
        {if (true) throw new ParseException("Improper termination of Do statement");}
     indent++;
     {if (true) return "while("+s1+"){\n";}
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String RestofCall() throws ParseException {
  String[] params = null;
  String s,s1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
    case LPAREN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      jj_consume_token(EQUALS);
      s = Expression("");
          if( mode <1)  {if (true) throw new ParseException("Cannot have a Call statement outside of a sub");}
          mode = 3;
          {if (true) return makeUpAssignmentStatement("CALL", params, s);}
      break;
    case SUBROUTINE:
    case FUNCTION:
    case INTEGER:
    case REAL:
    case CHARACTER:
    case LOGICAL:
    case EXTERNAL:
    case DIMENSION:
    case CONTINUE:
    case ELSE:
    case ENDIF:
    case IF:
    case DO:
    case CALL:
    case RETURN:
    case IDENTIFIER:
    case THEN:
    case TRUE:
    case FALSE:
    case EXP:
    case WRITE:
    case READ:
    case WHILE:
      s = PossVarName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
       s1=util.LocalInvokeFxnCode( s, params);
       if( s1 == null){
          s1 = util.OperatorInvokeFxnCode( s,params);
          threwException=true;

       }

      {if (true) return s1+";\n";}
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String RestofReturn() throws ParseException {
  String s;
  String[] params = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
    case LPAREN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      jj_consume_token(EQUALS);
      s = Expression("");
      jj_consume_token(EOLN);
          if( mode <1)  {if (true) throw new ParseException("Cannot have a statement outside of a sub");}
          mode = 3;

          {if (true) return makeUpAssignmentStatement("RETURN", params, s);}
      break;
    case EOLN:
      jj_consume_token(EOLN);
       {if (true) return "return null;\n";}
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String RestofEnd(String Res1 , String name) throws ParseException {
    String[] params = null;
    String s;
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 0:
    case EOLN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOLN:
        t = jj_consume_token(EOLN);
        break;
      case 0:
        t = jj_consume_token(0);
        break;
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        if( CurrentMethodName == null)
          {if (true) throw new ParseException( "There is no sub or function name for code");}
       filename = filename.replace( java.io.File.separatorChar,'/');
       int k7 = filename.lastIndexOf('/');
       if( k7 < 0)
           k7 = filename.length();
       String outFile = filename.substring( 0, k7);

       outFile = outFile+"/"+CurrentMethodName+".java";
       java.io.PrintStream pstrm=null;
       try{
          pstrm = new java.io.PrintStream(
                    new java.io.FileOutputStream(outFile));
       }catch( Exception sss){
          pstrm = System.out;
       }
       //----------- Header ------------------------
       pstrm.print("package ");
       String[] directs = util.dirList( filename, System.getProperty("java.class.path"));
       for(int kk=0; kk<directs.length; kk++){
         pstrm.print( directs[kk]);
         if( kk+1< directs.length)
           pstrm.print(".");
         else
           pstrm.println(";");
       }

       pstrm.println("import java.util.*;\n");
       pstrm.println("import DataSetTools.operator.*;\n");
       pstrm.println("import Command.JavaCC.Fortran.*;\n");
       pstrm.println("import gov.anl.ipns.Util.SpecialStrings.*;\n");
       pstrm.println("public class "+CurrentMethodName+
                " implements Wrappable,HiddenOperator{\n");
       //---- Declare Parameters  --------
       SetDataTypes( Variable);
       int j = 1;
       for( int i = Parameters.indexOf(";",j+1); (i>=0)&&(i <= Parameters.length()-1);
                               i = Parameters.indexOf(";",i+1)){
          String namee = Parameters.substring( j,i);
          j  = i+1;
          VariableInfo vbInf = (VariableInfo)Variable.get(namee);
          if( vbInf != null)
          if( vbInf.location ==1){
              pstrm.print(buff+"public "+ vbInf.DataType);
              if(vbInf.Parameters != null)
                for(int  jj=0; jj<vbInf.Parameters.length; jj++)
                   pstrm.print("[]");
              pstrm.println(" "+namee+"="+
                     getDefaultInitValue(vbInf.DataType,vbInf.Parameters)+";\n");
          }
       }//Go thru each variable;

       pstrm.println(buff+"public Object calculate(){\n");

       //----- Declare local variables ---------------
      for( int i=0; i < Variable.size(); i++){
          VariableInfo vbInf = (VariableInfo)Variable.getValue(i);
          if( vbInf.location ==2){
              String vname = Variable.getName(i);
              if( vname.equals(CurrentMethodName)) //Common block variables need help
                 vname+="result";
              pstrm.print( buff+buff+vbInf.DataType);
              if(vbInf.Parameters != null)
                for(  j=0; j<vbInf.Parameters.length; j++)
                   pstrm.print("[]");
              pstrm.print(" "+vname);
              if( vbInf.Parameters != null){
                pstrm.print( "= new "+vbInf.DataType);
                for(  j=0; j<vbInf.Parameters.length; j++){
                   String S =vbInf.Parameters[j];
                   if( S.indexOf(':')>0)
                      S = S.substring(0, S.indexOf(':'));
                   pstrm.print("["+S+"-"+Offset(Variable.getName(i),j)+"+1]");
                }
                pstrm.println(";\n");
              }else
                pstrm.println("="+getDefaultInitValue(vbInf.DataType,
                           null)+";\n");
                      ;
          }
       }//Go thru each variable;
       pstrm.println(buff+buff+"//-------------- code ------------");
       pstrm.println( Res1);//Print the code
      if( ! checkVariable( CurrentMethodName, -1))
         pstrm.println(buff+buff+"return null;\n");
      else {
        VariableInfo vbInf =(VariableInfo)Variable.get( CurrentMethodName);
        String vname = CurrentMethodName+"result";
        if( vbInf.DataType.equals("String"))
           pstrm.println(buff+buff+"return "+vname+";\n");
        else if( (vbInf.Parameters != null) && (vbInf.Parameters.length >0))
            pstrm.println(buff+buff+"return "+vname+";\n");
        else{
          String sz = vbInf.DataType;
          if( sz.equals("int"))
             pstrm.println(buff+buff+"return new Integer("+vname+");\n");
          else if( sz.equals("float"))
             pstrm.println(buff+buff+"return new Float("+vname+");\n");
          else if( sz.equals("double"))
             pstrm.println(buff+buff+"return new Double("+vname+");\n");
          else if( sz.equals("long"))
             pstrm.println(buff+buff+"return new Long("+vname+");\n");
          else if( sz.equals("short"))
             pstrm.println(buff+buff+"return new Short("+vname+");\n");
          else if( sz.equals("byte"))
             pstrm.println(buff+buff+"return new Byte("+vname+");\n");
          else
             pstrm.println(buff+buff+"return null;\n");

        }
      }
      pstrm.println(buff+"}");

      pstrm.println(buff+"public String getCommand(){");
      pstrm.println(buff+buff+"return \""+CurrentMethodName+"\";}\n\n");
      pstrm.println(buff+"public String getDocumentation(){");
      pstrm.println(  buff+buff+"return \" Default Docs \";}");

     pstrm.println("}");


      //------Get ready for next sub-------
    try{
       pstrm.close();
       }catch( Exception sss){}
       mode=0;
       CurrentMethodName = null;
       Res ="";
       doLabels = ";";
       Parameters = ";";
       Variable = new ListHandler();
       if(t.kind == EOF)
          Finished = true;
       {if (true) return "";}
      break;
    case EQUALS:
    case LPAREN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[33] = jj_gen;
        ;
      }
      jj_consume_token(EQUALS);
      s = Expression("");
      jj_consume_token(EOLN);
          if( mode <1)  {if (true) throw new ParseException("Cannot have a statement outside of a sub");}
          mode = 3;
          {if (true) return makeUpAssignmentStatement(name, params, s);}
      break;
    case IF:
      jj_consume_token(IF);
      jj_consume_token(EOLN);
      indent--;
      {if (true) return Pretty(indent, "}\n");}
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
void RestOfParamList():{
 String t;
 }
 {
   <COMMA> t=PossVarName() RestOfParamList()
     {
      

     }|
   <RPAREN><EOLN>
 }
*/


/*------------------ Expression--------------------*/
  final public String Expression(String prevOp) throws ParseException {
 Token t1 = null,
       t2 = null;
 String s,
        //s1="",
        s2="",
        s3,
        lparens="";
    if (jj_2_1(2)) {
      jj_consume_token(LOGDOT);
      jj_consume_token(NOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        break;
      case LOGDOT:
        jj_consume_token(LOGDOT);
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      s = Expression("");
         {if (true) return "!"+s;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUBROUTINE:
      case FUNCTION:
      case INTEGER:
      case REAL:
      case CHARACTER:
      case LOGICAL:
      case EXTERNAL:
      case DIMENSION:
      case CONTINUE:
      case ELSE:
      case ENDIF:
      case IF:
      case DO:
      case CALL:
      case RETURN:
      case IDENTIFIER:
      case THEN:
      case INTNUM:
      case LPAREN:
      case DOT:
      case TRUE:
      case FALSE:
      case PLUS:
      case MINUS:
      case STRING:
      case EXP:
      case WRITE:
      case READ:
      case WHILE:
        s = NonAndOrExpression();
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LOGDOT:
            ;
            break;
          default:
            jj_la1[36] = jj_gen;
            break label_4;
          }
          jj_consume_token(LOGDOT);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case AND:
            t1 = jj_consume_token(AND);
            break;
          case OR:
            t1 = jj_consume_token(OR);
            break;
          default:
            jj_la1[37] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LOGDOT:
            jj_consume_token(LOGDOT);
            break;
          case DOT:
            jj_consume_token(DOT);
            break;
          default:
            jj_la1[38] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LOGDOT:
            jj_consume_token(LOGDOT);
            t2 = jj_consume_token(NOT);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DOT:
              jj_consume_token(DOT);
              break;
            case LOGDOT:
              jj_consume_token(LOGDOT);
              break;
            default:
              jj_la1[39] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[40] = jj_gen;
            ;
          }
          s3 = NonAndOrExpression();
              if(t1.kind ==AND)
                s2+="&&";
              else
                s2+="||";
              if( t2 != null)
                s2 +='!';
              s2+=s3+")";
              lparens+="(";
        }
       {if (true) return lparens+"("+s+s2+")";}
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public String RestOfExpression(String prevOp) throws ParseException {
  Token t;
  String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOGDOT:
      jj_consume_token(LOGDOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        t = jj_consume_token(AND);
        break;
      case OR:
        t = jj_consume_token(OR);
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGDOT:
        jj_consume_token(LOGDOT);
        break;
      case DOT:
        jj_consume_token(DOT);
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      s = Expression("AND");
       if(prevOp.equals("AND")){
         //lp = "(";
         //rp=")";
       }
       if( t.kind == AND)
         {if (true) return "&&"+s;}

       else
         {if (true) return "||"+s;}
      break;
    default:
      jj_la1[44] = jj_gen;
       {if (true) return "";}
    }
    throw new Error("Missing return statement in function");
  }

  final public String NonAndOrExpression() throws ParseException {
 //Token t1=null,
 //      t2;
 String s,
        s1="";
    s = AlgExpression();
    s1 = RestOfNonAndOrExpression();
       {if (true) return "("+s+s1+")";}
    throw new Error("Missing return statement in function");
  }

  final public String RestOfNonAndOrExpression() throws ParseException {
 Token t1=null;
       //t2;
 String s;
    if (jj_2_2(2)) {
      jj_consume_token(LOGDOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NE:
        t1 = jj_consume_token(NE);
        break;
      case EQ:
        t1 = jj_consume_token(EQ);
        break;
      case LT:
        t1 = jj_consume_token(LT);
        break;
      case LE:
        t1 = jj_consume_token(LE);
        break;
      case GT:
        t1 = jj_consume_token(GT);
        break;
      case GE:
        t1 = jj_consume_token(GE);
        break;
      default:
        jj_la1[45] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        break;
      case LOGDOT:
        jj_consume_token(LOGDOT);
        break;
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      s = AlgExpression();
         if(t1==null)
           {if (true) return "";}

         else if( t1.kind==NE)
           {if (true) return ")!=("+s;}

         else if( t1.kind==EQ)
           {if (true) return ")==("+s;}

         else if( t1.kind==LT)
           {if (true) return ")<("+s;}

         else if( t1.kind==LE)
           {if (true) return ")<=("+s;}

         else if( t1.kind==GT)
           {if (true) return ")>("+s;}

         else if( t1.kind==GE)
           {if (true) return ")>=("+s;}

         else
           {if (true) return "";}
    } else if (jj_2_3(2)) {
      jj_consume_token(LOGDOT);
      jj_consume_token(TRUE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        break;
      case LOGDOT:
        jj_consume_token(LOGDOT);
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         {if (true) return "true";}
    } else if (jj_2_4(2)) {
      jj_consume_token(LOGDOT);
      jj_consume_token(FALSE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        break;
      case LOGDOT:
        jj_consume_token(LOGDOT);
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         {if (true) return "false";}
    } else {
     {if (true) return "";}
    }
    throw new Error("Missing return statement in function");
  }

  final public String AlgExpression() throws ParseException {
 Token t=null;
       //t1;
 String s1,
        s2="";
    s1 = termOfExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      s2 = AlgExpression();
      break;
    default:
      jj_la1[50] = jj_gen;
      ;
    }
       if( t== null)
         {if (true) return s1;}

       else if( t.kind ==PLUS)
         {if (true) return s1+"+"+s2;}

       else
         {if (true) return s1+"-"+s2;}
    throw new Error("Missing return statement in function");
  }

  final public String termOfExpression() throws ParseException {
 Token t=null;
       //t1;
 String s,
        s2="",
        s3="";
    s = FactorOfExpression();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROD:
      case DIVISION:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROD:
        t = jj_consume_token(PROD);
        break;
      case DIVISION:
        t = jj_consume_token(DIVISION);
        break;
      default:
        jj_la1[52] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      s2 = FactorOfExpression();
           if( t.kind == PROD)
             s3+="*"+s2;

           else
             s3+= "/"+s2;
    }
           if( t== null)
             {if (true) return s;}

           else
             {if (true) return s+s3;}
    throw new Error("Missing return statement in function");
  }

  final public String FactorOfExpression() throws ParseException {
 Token //t=null,
       t1=null,
       t3=null;
 String s,
        s2="",
        s3,
        s4="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        t3 = jj_consume_token(MINUS);
        break;
      case PLUS:
        t3 = jj_consume_token(PLUS);
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    s = OneFactor();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POWER:
        ;
        break;
      default:
        jj_la1[55] = jj_gen;
        break label_6;
      }
      jj_consume_token(POWER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          t1 = jj_consume_token(PLUS);
          break;
        case MINUS:
          t1 = jj_consume_token(MINUS);
          break;
        default:
          jj_la1[56] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
      s3 = OneFactor();
           s4="";
           if( t1!=null)
             if(t1.kind == MINUS)
               s4="-";
           s2+= s4+s3;
    }
         String sign="";
         if( t3!=null)
           if( t3.kind==MINUS)
             sign="-";

         if( s2=="")
           {if (true) return sign+s;}

         {if (true) return sign+"Math.pow("+s+","+s2+")";}
    throw new Error("Missing return statement in function");
  }

// TODO  TRUE and FALSE, LOOKAHEAD does not work so must chain as usual
  final public String OneFactor() throws ParseException {
 Token t1;
 String s,s1;
 String[] params = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUBROUTINE:
    case FUNCTION:
    case INTEGER:
    case REAL:
    case CHARACTER:
    case LOGICAL:
    case EXTERNAL:
    case DIMENSION:
    case CONTINUE:
    case ELSE:
    case ENDIF:
    case IF:
    case DO:
    case CALL:
    case RETURN:
    case IDENTIFIER:
    case THEN:
    case TRUE:
    case FALSE:
    case EXP:
    case WRITE:
    case READ:
    case WHILE:
      s = PossVarName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        params = ExpressionList();
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
       if( !checkVariable( s.toUpperCase(),-1))
         if(params == null){
          //String type ="float";
          //if( "IJKLMNO".indexOf( s.toUpperCase().charAt(0))>=0)
             //type ="int";
          addVariable( s.toUpperCase(), "dimension",-1,params);
          {if (true) return s.toUpperCase();}
         }else{ //Must be a function returns a number
           String dt = "float";
           if( "IJKLMN".indexOf( s.toUpperCase().charAt(0)) >=0)
              dt = "int";
           s1 = util.JavaInvokeIntrinsic(s,params);
           if( s1 == null)
              s1=util.LocalInvokeFxnCode(s,params);
           if( s1 == null){
              s1 = util.OperatorInvokeFxnCode(s, params);
              s1 ="((Number)("+s1+"))."+dt+"Value()";

              threwException = true;
           }
          {if (true) return s1;}
         }

        else{//could be external fxn
           VariableInfo vinf= (VariableInfo)Variable.get( s.toUpperCase());

           if((vinf.location ==2)|| (vinf.location ==1) ||(vinf.location < 0))
              if(params == null)
                {if (true) return s.toUpperCase();}
              else{//is array
                s = s.toUpperCase();
                String S1 = s;

                for( int i=0; i< params.length; i++){
                     s +="[(int)("+params[i]+"-"+Offset(S1,i)+")]";

                 }
                 {if (true) return s;}
              }
           else{//Function
              s1= util.JavaInvokeIntrinsic( s, params);
              if( s1 == null)
                s1= util.LocalInvokeFxnCode( s, params);
              if(s1 == null){
                s1=util.OperatorInvokeFxnCode( s, params);
                if(vinf.DataType.equals("String"))
                  s1 +=".toString()";
                else if( vinf.DataType.equals("boolean"))
                  s1="((Boolean)("+s+").getbooleanValue())";
                else
                  s1="((Number)"+s1+")."+vinf.DataType+"Value()";
                threwException = true;
               {if (true) return s1;}
              }
           }
        }
      break;
    case INTNUM:
    case DOT:
      s = Number();
       {if (true) return s;}
      break;
    case STRING:
      t1 = jj_consume_token(STRING);
       {if (true) return "\""+t1.image+"\"";}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      s = Expression("");
      jj_consume_token(RPAREN);
       {if (true) return "("+s+")";}
      break;
    default:
      jj_la1[59] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*------------------ Number------------------------*/
  final public String Number() throws ParseException {
 Token t1=null,
       t2=null,
       t3=null;
 String s="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTNUM:
      t1 = jj_consume_token(INTNUM);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        t3 = jj_consume_token(DOT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTNUM:
          t2 = jj_consume_token(INTNUM);
          break;
        default:
          jj_la1[60] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXP:
        s = ExponentialExpression();
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
       if(t2 == null)
         if( t3==null)
           {if (true) return t1.image+s;}

         else
           {if (true) return t1.image+"."+s;}

       else
         {if (true) return t1.image+"."+t2.image+s;}
      break;
    case DOT:
      jj_consume_token(DOT);
      t1 = jj_consume_token(INTNUM);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXP:
        s = ExponentialExpression();
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
        {if (true) return "."+t1.image+s;}
      break;
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String ExponentialExpression() throws ParseException {
 Token t=null,
       t1=null;
 String //s,
        pm;
    jj_consume_token(EXP);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t1 = jj_consume_token(PLUS);
        break;
      case MINUS:
        t1 = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
    t = jj_consume_token(INTNUM);
       pm="";
       if( t1 != null)
         if( t1.kind==MINUS)
           pm="-";

       {if (true) return "E"+pm+t.image;}
    throw new Error("Missing return statement in function");
  }

  final public void NumTerminator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EOLN:
      jj_consume_token(EOLN);
      break;
    case RPAREN:
      jj_consume_token(RPAREN);
      break;
    case COMMA:
      jj_consume_token(COMMA);
      break;
    case PLUS:
      jj_consume_token(PLUS);
      break;
    case MINUS:
      jj_consume_token(MINUS);
      break;
    case PROD:
      jj_consume_token(PROD);
      break;
    case DIVISION:
      jj_consume_token(DIVISION);
      break;
    case POWER:
      jj_consume_token(POWER);
      break;
    default:
      jj_la1[67] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*--------------------- List to get tokens into constants -----------------------*/
  final public void Expression7() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 0:
      jj_consume_token(0);
      break;
    case MATHOP:
      jj_consume_token(MATHOP);
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      break;
    case IDENTIFIER:
      jj_consume_token(IDENTIFIER);
      break;
    case FLOATNUM:
      jj_consume_token(FLOATNUM);
      break;
    case INTNUM:
      jj_consume_token(INTNUM);
      break;
    case ERROR:
      jj_consume_token(ERROR);
      break;
    case EOLN:
      jj_consume_token(EOLN);
      break;
    case RPAREN:
      jj_consume_token(RPAREN);
      break;
    case COMMA:
      jj_consume_token(COMMA);
      break;
    case PLUS:
      jj_consume_token(PLUS);
      break;
    case MINUS:
      jj_consume_token(MINUS);
      break;
    case PROD:
      jj_consume_token(PROD);
      break;
    case DIVISION:
      jj_consume_token(DIVISION);
      break;
    case POWER:
      jj_consume_token(POWER);
      break;
    case IF:
      jj_consume_token(IF);
      break;
    case THEN:
      jj_consume_token(THEN);
      break;
    case DO:
      jj_consume_token(DO);
      break;
    case EQUALS:
      jj_consume_token(EQUALS);
      break;
    case WRITE:
      jj_consume_token(WRITE);
      break;
    case READ:
      jj_consume_token(READ);
      break;
    case LT:
      jj_consume_token(LT);
      break;
    case GT:
      jj_consume_token(GT);
      break;
    case LE:
      jj_consume_token(LE);
      break;
    case GE:
      jj_consume_token(GE);
      break;
    case EQ:
      jj_consume_token(EQ);
      break;
    case AND:
      jj_consume_token(AND);
      break;
    case OR:
      jj_consume_token(OR);
      break;
    case NOT:
      jj_consume_token(NOT);
      break;
    case INTEGER:
      jj_consume_token(INTEGER);
      break;
    case REAL:
      jj_consume_token(REAL);
      break;
    case DIMENSION:
      jj_consume_token(DIMENSION);
      break;
    case CHARACTER:
      jj_consume_token(CHARACTER);
      break;
    case LOGICAL:
      jj_consume_token(LOGICAL);
      break;
    case EXTERNAL:
      jj_consume_token(EXTERNAL);
      break;
    case ENDIF:
      jj_consume_token(ENDIF);
      break;
    case ELSE:
      jj_consume_token(ELSE);
      break;
    case SUBROUTINE:
      jj_consume_token(SUBROUTINE);
      break;
    case FUNCTION:
      jj_consume_token(FUNCTION);
      break;
    case CONTINUE:
      jj_consume_token(CONTINUE);
      break;
    case LABEL:
      jj_consume_token(LABEL);
      break;
    case STRING:
      jj_consume_token(STRING);
      break;
    case COMMENT:
      jj_consume_token(COMMENT);
      break;
    case DOT:
      jj_consume_token(DOT);
      break;
    case NE:
      jj_consume_token(NE);
      break;
    case EXP:
      jj_consume_token(EXP);
      break;
    case END:
      jj_consume_token(END);
      break;
    case LOGDOT:
      jj_consume_token(LOGDOT);
      break;
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String PossVarName() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
                  {if (true) return t.image;}
      break;
    case SUBROUTINE:
      jj_consume_token(SUBROUTINE);
                {if (true) return "SUBROUTINE";}
      break;
    case FUNCTION:
      jj_consume_token(FUNCTION);
              {if (true) return "FUNCTION";}
      break;
    case THEN:
      jj_consume_token(THEN);
                                         {if (true) return "THEN";}
      break;
    case IF:
      jj_consume_token(IF);
       {if (true) return "IF";}
      break;
    case DO:
      jj_consume_token(DO);
                           {if (true) return "DO";}
      break;
    case WRITE:
      jj_consume_token(WRITE);
                                                 {if (true) return "WRITE";}
      break;
    case READ:
      jj_consume_token(READ);
         {if (true) return "READ";}
      break;
    case INTEGER:
      jj_consume_token(INTEGER);
                                    {if (true) return "INTEGER";}
      break;
    case REAL:
      jj_consume_token(REAL);
                                                               {if (true) return "REAL";}
      break;
    case DIMENSION:
      jj_consume_token(DIMENSION);
               {if (true) return "DIMENSION";}
      break;
    case CHARACTER:
      jj_consume_token(CHARACTER);
                                                {if (true) return "CHARACTER";}
      break;
    case LOGICAL:
      jj_consume_token(LOGICAL);
                                                                                {if (true) return "LOGICAL";}
      break;
    case EXTERNAL:
      jj_consume_token(EXTERNAL);
              {if (true) return "EXTERNAL";}
      break;
    case ENDIF:
      jj_consume_token(ENDIF);
                                           {if (true) return "ENDIF";}
      break;
    case ELSE:
      jj_consume_token(ELSE);
         {if (true) return "ELSE";}
      break;
    case CONTINUE:
      jj_consume_token(CONTINUE);
                                    {if (true) return "CONTINUE";}
      break;
    case EXP:
      jj_consume_token(EXP);
        {if (true) return "EXP";}
      break;
    case WHILE:
      jj_consume_token(WHILE);
                                {if (true) return "WHILE";}
      break;
    case TRUE:
      jj_consume_token(TRUE);
                                                        {if (true) return "TRUE";}
      break;
    case FALSE:
      jj_consume_token(FALSE);
        {if (true) return "FALSE";}
      break;
    case CALL:
      jj_consume_token(CALL);
                                {if (true) return "CALL";}
      break;
    case RETURN:
      jj_consume_token(RETURN);
                                                          {if (true) return "RETURN";}
      break;
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*-------------------------  Lists --------------------------------*/
  final public String[] ExpressionList() throws ParseException {
 //Token t;
 String[] Res= new String[0],
          Res1;;
 String s="",
        s1="";
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUBROUTINE:
    case FUNCTION:
    case INTEGER:
    case REAL:
    case CHARACTER:
    case LOGICAL:
    case EXTERNAL:
    case DIMENSION:
    case CONTINUE:
    case ELSE:
    case ENDIF:
    case IF:
    case DO:
    case CALL:
    case RETURN:
    case IDENTIFIER:
    case THEN:
    case INTNUM:
    case LPAREN:
    case LOGDOT:
    case DOT:
    case TRUE:
    case FALSE:
    case PLUS:
    case MINUS:
    case STRING:
    case EXP:
    case WRITE:
    case READ:
    case WHILE:
      s = Expression("");
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[70] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        s1 = Expression("");
                    Res1 = new String[Res.length+1];
                    System.arraycopy( Res,0,Res1,0,Res.length);
                    Res1[Res1.length-1]= s1;
                    Res=Res1;
      }
      break;
    default:
      jj_la1[71] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    Res1 = new String[Res.length+1];
    System.arraycopy( Res,0,Res1,1,Res.length);
    Res1[0]= s;
    {if (true) return Res1;}
    throw new Error("Missing return statement in function");
  }

  final public String[] ArgList() throws ParseException {
  String s=null;//s1=null,s2;
  String[] Res;
  //Token t;
  LinkedList LL = new LinkedList();
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUBROUTINE:
    case FUNCTION:
    case INTEGER:
    case REAL:
    case CHARACTER:
    case LOGICAL:
    case EXTERNAL:
    case DIMENSION:
    case CONTINUE:
    case ELSE:
    case ENDIF:
    case IF:
    case DO:
    case CALL:
    case RETURN:
    case IDENTIFIER:
    case THEN:
    case INTNUM:
    case LPAREN:
    case LOGDOT:
    case DOT:
    case TRUE:
    case FALSE:
    case PLUS:
    case MINUS:
    case PROD:
    case STRING:
    case EXP:
    case WRITE:
    case READ:
    case WHILE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUBROUTINE:
      case FUNCTION:
      case INTEGER:
      case REAL:
      case CHARACTER:
      case LOGICAL:
      case EXTERNAL:
      case DIMENSION:
      case CONTINUE:
      case ELSE:
      case ENDIF:
      case IF:
      case DO:
      case CALL:
      case RETURN:
      case IDENTIFIER:
      case THEN:
      case INTNUM:
      case LPAREN:
      case LOGDOT:
      case DOT:
      case TRUE:
      case FALSE:
      case PLUS:
      case MINUS:
      case STRING:
      case EXP:
      case WRITE:
      case READ:
      case WHILE:
        s = Expression("");
        break;
      case PROD:
        jj_consume_token(PROD);
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
              if( s != null)
                 LL.add( s);
              else
                 LL.add( "*");
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[73] = jj_gen;
          break label_8;
        }
        jj_consume_token(COMMA);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SUBROUTINE:
        case FUNCTION:
        case INTEGER:
        case REAL:
        case CHARACTER:
        case LOGICAL:
        case EXTERNAL:
        case DIMENSION:
        case CONTINUE:
        case ELSE:
        case ENDIF:
        case IF:
        case DO:
        case CALL:
        case RETURN:
        case IDENTIFIER:
        case THEN:
        case INTNUM:
        case LPAREN:
        case LOGDOT:
        case DOT:
        case TRUE:
        case FALSE:
        case PLUS:
        case MINUS:
        case STRING:
        case EXP:
        case WRITE:
        case READ:
        case WHILE:
          s = Expression("");
          break;
        case PROD:
          jj_consume_token(PROD);
          break;
        default:
          jj_la1[74] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                     if( s != null)
                       LL.add( s);
                     else
                        LL.add( "*");
      }
      break;
    default:
      jj_la1[75] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
     Res = new String[LL.size()];
     if(Res.length <1)
       {if (true) return Res;}
     ListIterator Lit = LL.listIterator(0);
     int i=0;
     while( Lit.hasNext()){

       Res[i]=(String)Lit.next();
       i++;
    }
    {if (true) return Res;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(LOGDOT)) return true;
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(LOGDOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_scan_token(LOGDOT)) return true;
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(LOGDOT)) return true;
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  public TokenManager token_source;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[76];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x3ffffe,0x3ffffe,0x4000000,0x4000000,0x4000000,0x3ffff4,0x4000000,0x4000000,0x576fff0,0x4000000,0x136fff0,0x4000000,0x800000,0x4000000,0x576fff0,0x4000000,0x800000,0x576fff0,0x4000000,0x4400004,0x17ffff4,0x4000000,0x4400004,0x4000000,0x6400000,0x800000,0x4400000,0x4000000,0x4000000,0x576fff0,0x4000000,0x4400004,0x5,0x4000000,0x4408005,0x50000000,0x10000000,0x80000000,0x50000000,0x50000000,0x10000000,0x4736fff0,0x80000000,0x50000000,0x10000000,0x0,0x50000000,0x50000000,0x50000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x4736fff0,0x2000000,0x40000000,0x0,0x0,0x42000000,0x0,0x0,0x8800004,0xffeaffff,0x136fff0,0x800000,0x5736fff0,0x5736fff0,0x800000,0x5736fff0,0x5736fff0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x388180,0x0,0x388180,0x0,0x0,0x0,0x388180,0x0,0x0,0x388180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x388180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x38c780,0x1,0x0,0x0,0x7e,0x0,0x0,0x0,0x600,0x600,0x1800,0x1800,0x600,0x600,0x2000,0x600,0x600,0x0,0x38c180,0x0,0x0,0x8000,0x8000,0x0,0x600,0x600,0x3e00,0x1ffe7f,0x388180,0x0,0x38c780,0x38cf80,0x0,0x38cf80,0x38cf80,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[4];
  private boolean jj_rescan = false;
  private int jj_gc = 0;


  public Fcvrt(TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 76; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 76; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[54];
    for (int i = 0; i < 54; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 76; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 54; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

  //Pretty
}
class VariableInfo{
  public String DataType;
  public int location;
  public String[] Parameters;
  public VariableInfo( String DataType, int location, String[] Parameters){
     this.DataType = DataType;
     this.location  = location;
     this.Parameters = Parameters;
  }
}
