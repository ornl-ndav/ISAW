/*
 * File:  FortranParser.jj
 *
 * Copyright (C) 2003, Chris M. Bouzek
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
 *
 * Contact : Dennis Mikkelson <mikkelsond@uwstout.edu>
 *           Department of Mathematics, Statistics and Computer Science
 *           University of Wisconsin-Stout
 *           Menomonie, WI 54751, USA
 *
 *           Chris Bouzek <coldfusion78@yahoo.com>
 *
 * This work was supported by the National Science Foundation under grant
 * number DMR-0218882.
 *
 * For further information, see <http://www.pns.anl.gov/ISAW/>
 *
 * $Log$
 * Revision 1.13  2004/01/15 00:44:38  bouzekc
 * Now handles single and multi line if statements.  Now more sophisticated
 * when determining whether to append a semicolon to the end of a line.
 *
 * Revision 1.12  2004/01/14 21:55:13  bouzekc
 * Fixed a bug with math expression parentheses.
 *
 * Revision 1.11  2004/01/14 21:41:36  bouzekc
 * Now allows math expressions, assignment from math expressions, and
 * assignment to variables.
 *
 * Revision 1.10  2004/01/14 19:59:09  bouzekc
 * Added ability to add comments.  Fixed bug where multiple double
 * initializations crashed.
 *
 * Revision 1.9  2004/01/14 06:38:17  bouzekc
 * Now handles initialization in variable declaration for scalar and array
 * types as well as mixed types.  Removed the MULTI_VARIABLE token, as it
 * is no longer used.
 *
 * Revision 1.8  2004/01/14 06:06:00  bouzekc
 * Fixed remaining bugs dealing with mixing array and scalar declarations.
 *
 * Revision 1.7  2004/01/14 05:07:28  bouzekc
 * Fixed most of the bugs with array variable declaration.
 *
 * Revision 1.6  2004/01/14 04:37:43  bouzekc
 * Added remainder of geometric math functions, added code to handle
 * the Fortran fraction() function using Math.IEEERemainder().
 *
 * Revision 1.5  2004/01/14 01:54:33  bouzekc
 * Cleaned up old, unused token statements, and more explicitly defined
 * each token so that there is no ambiguity between the regular
 * expression versions of each.  Added comments to each token and to the
 * uncommented sections of Java code.
 *
 * Revision 1.4  2004/01/14 01:30:28  bouzekc
 * Fixed bug in second type of character variable declaration handling.
 * All variables that are used outside of enclosing tokens are now able to
 * handle leading and trailing whitespace by themselves, so the check for
 * leading whitespace was removed from the main parsing code.  Fixed the
 * conversion of real() and int() to the correct Java "versions."
 *
 * Revision 1.3  2004/01/14 00:07:26  bouzekc
 * Added code to handle MOD.  Reorganized whitespace tokens.
 *
 * Revision 1.2  2004/01/07 15:54:54  bouzekc
 * Added abs(), sqrt(), float(), and int() function recognition.
 *
 * Revision 1.1  2004/01/06 23:13:49  bouzekc
 * Added to CVS.  Only bare functionality exists at this point.
 *
 */
PARSER_BEGIN( FortranParser )
package Command.JavaCC.Fortran;

import java.io.StringReader;

import java.util.*;

public class FortranParser {
  //don't want to continually recreate this thing
  private static FortranParser myParser;
  private static boolean appendSemiColon = false;
  private static boolean standalone = false;
  
  /**
   * Method used to run the FortranParser for testing purposes.
   *
   * @param args Unused.
   *
   * @throws ParseException If anything goes wrong during parsing
   */
  public static void main( String args[] ) throws ParseException {
    standalone = true;
    myParser = new FortranParser( System.in );
    myParser.parseCode(  );
  }

  /**
   *  Used to call the parser from an outside class.  Returns a String in Java
   *  for each line of Fortran code.
   *
   * @param text The text to parse.
   *
   * @return The result of the parsing.
   *
   * @throws ParseException If anything goes wrong during parsing
   */
  public static String parseText( String text ) throws ParseException {
    standalone = false;
    //need a semicolon on the end
    if( text.indexOf( ";" ) < 0 ) {
      text = text.trim(  ) + ";";
    }
    if( myParser == null ) {
      myParser = new FortranParser( new StringReader( text )  );
    } else {
      myParser.ReInit( new StringReader( text )  );
    }
    String line = myParser.parseCode(  );

    if( line == null || line.length(  ) <= 0 ) {
      return "";
    }  else  {
      return line;
    }
  }
  
  /**
   * Method to convert fromFortran style array and variable 
   * declaration to Java style array and variable declaration.
   * If no array declarations exist, this essentially just converts from
   * Fortran type declaration to Java type declaration.
   * 
   * @param s The String to convert Fortran arrays from.
   * @param type The type (e.g. int) of the array.
   * 
   * @return The String representing the passed in String converted
   *                 to Java style arrays.
   */
  private static String convertToJavaStyle( 
    String s, String type ) { 
    StringBuffer buffer = new StringBuffer( type );
    buffer.append( " " );
    //make sure these get a semicolon
    appendSemiColon = true;
    
    //the parentheses should NOT be right at the beginning of the declaration
    if( s.indexOf( "(" ) > 0 ) {    
      String tokenList[] = s.split( "," );
      //now go through the tokens, determining if an element is an array
      String[] temp;
      for( int i = 0; i < tokenList.length; i++ ) {
        if( tokenList[i].indexOf( "(" ) >= 0 ) {
          //change to Java style array delimiters
          tokenList[i] = tokenList[i].replace( '(', '[' );
          tokenList[i] = tokenList[i].replace( ')', ']' );
          //this will split the String just after the variable name.  We
          //will have to put the '[' back on however
          temp = tokenList[i].split( "\\[" );
          tokenList[i] = temp[0] + " = new " + type + "[" + temp[1];

        }
                
        //put the token (array element or not) in
        buffer.append( tokenList[i] );
        
        //basically, put the commas back in
        if( i < tokenList.length - 1 ) {
          buffer.append( "," );
        }
      }
    } else {
      //just return what we had after initial replacements
      buffer.append( s );
    }  

    return buffer.toString(  );
  }
  
  /**
   * Simply replaces any occurrences of opName in s with Math.opName.
   * 
   * @return The converted String.
   */
  private static String convertMath( String s, String opName ){
    return s.replaceAll( opName, "Math." + opName );
  }
  
}
     
PARSER_END( FortranParser )

//~----------------------------------------------------------------------------
// A NOTE TO MAINTAINERS OF THIS CODE:
//
// ALL TOKENS THAT YOU ARE PROCESSING IN THE PRODUCTIONS
// SHOULD HAVE THE <OPT_WS> BEFORE AND AFTER THEIR
// DECLARATIONS, UNLESS THEY ARE MEANT SPECIFICALLY TO BE
// USED DIRECTLY BEFORE OR AFTER ANOTHER TOKEN.  IF THIS
// RULE IS NOT FOLLOWED, THE PARSER WILL NOT ALWAYS
// WORK CORRECTLY, AS IT DOES NOT EXPLICITLY LOOK FOR
// WHITESPACE WHEN PROCESSING A LINE.
//
// -CHRIS BOUZEK
//~----------------------------------------------------------------------------   

//lines in Fortran are not ended with a semicolon or anything
//nice like that
TOKEN : {
  < LINE_END: ("\n"| "\r"| "\r\n") >
}

//whitespace: space or tab
TOKEN : {
  < #WHITESPACE: (" " | "\t" ) >
}

//at least one whitespace character
TOKEN : {
  < ONE_PLUS_WS: ( <WHITESPACE> )+ >
}

//one or more whitespace characters
TOKEN : {
  < #OPT_WS: ( <WHITESPACE> )* >
}

//left parentheses, surrounded by optional whitespace
TOKEN: {
  <#LPAREN: (
    <OPT_WS> "(" <OPT_WS>
  ) >
}

//right parentheses, surrounded by optional whitespace
TOKEN: {
  <#RPAREN: (
    <OPT_WS> ")" <OPT_WS>
  ) >
}

//represents a single digit unsigned integer
TOKEN : {
  < #UNSIGNED_DIGIT: ( ["0"-"9"] ) >
}

//represents a single digit integer with an optional +/-
TOKEN : {
  < DIGIT: ( "+" | "-" )? <UNSIGNED_DIGIT> >
}

//represents the characters a-z, A-Z, _, or -
TOKEN : {
  < #CHARACTER: ["a"-"z", "A"-"Z", "_", "-" ] >
}

//represents a set of reserved characters not generally usable in 
//a normal character set
TOKEN : {
  < #RESERVED_CHAR: ( ~["a"-"z", "A"-"Z", "0"-"9", " ", "\t", "|", "\\", ":", 
                        "\n", "\r", "/", "\"", "+"] ) >
}

//represents a set of characters that cannot be used in a variable name
TOKEN : {
  < #VAR_RESERVED_CHAR: ["|", "\\", "/"] >
}

//single unsigned digit or character
TOKEN : {
  < #DIGICHAR : ( 
    <UNSIGNED_DIGIT> | <CHARACTER>
  ) >
}

//represents a variable, which is composed of a leading character 
//followed by any number of characters or unsigned digits, all 
//"bracketed" by optional whitespace
TOKEN : {
  < #VARIABLE : ( 
    ( <OPT_WS>
      ( <CHARACTER> )+ ( <DIGICHAR> )* 
    ) <OPT_WS>
  ) >
}

//Fortran array variable.  Variable name followed by a number in 
//parentheses, all "bracketed" by optional whitespace
TOKEN: {
  < #ARRAY_VARIABLE: (
    <OPT_WS>
    <VARIABLE> <LPAREN> ( <UNSIGNED_DIGIT> )+ <RPAREN>
    <OPT_WS>
  ) >
}

//component of a String.  Refactored so that it could be used in comments
//as well
TOKEN: {
  < #STRING_COMP: (
      <DIGICHAR> | 
      <RESERVED_CHAR> |
      <VAR_RESERVED_CHAR> | 
      <ONE_PLUS_WS> | 
      <FLOATING_POINT> |
      <DIGIT> |
      ":" |
      "''"  
  ) >
}

//String.  Represented by opening and closing double quotes, with
//digits, characters, reserved characters, variable reserved characters,
//one or more whitespaces, floating point numbers, :, '', 
//all "bracketed" by optional whitespace
TOKEN : {
  < STRING: (
    <OPT_WS>
    ( "\"" ) ( 
      <STRING_COMP>
    )* ( "\"" )
    <OPT_WS> 
  ) >
}

//floating point number "bracketed" by optional whitespace
TOKEN : {
  < FLOATING_POINT: (
    <OPT_WS>
    ( 
      ( 
        ( <DIGIT> )+ ( "." )? ( <UNSIGNED_DIGIT> )* 
      ) 
      | 
      ( 
        "." ( <UNSIGNED_DIGIT> )+ 
      ) 
    ) 
    ( 
      ["e", "E"] ( <DIGIT>)+ 
    )?
    <OPT_WS> 
  ) >
}

//~----------------------------------------------------------------------------
// FORTRAN SECTION
//~----------------------------------------------------------------------------

//~----------------------------------------------------------------------------
// FORTRAN CONSTANTS
//~----------------------------------------------------------------------------

//handles the Fortran logical (i.e. boolean) constants
TOKEN: {
  < #BOOL_CONST: (
    <OPT_WS> ( 
      ".TRUE." | ".FALSE." | ".true." | ".false."
    ) <OPT_WS> 
  ) >
}

//This is the Fortran comment.  The C must be in the first column, following
//Fortran style
TOKEN: {
  < FORTRAN_COMMENT: (
    ( "C " | "c " ) <OPT_WS> ( <STRING_COMP> )* <OPT_WS>
  ) >
} 

//~----------------------------------------------------------------------------
// FORTRAN VARIABLE TYPES
//~----------------------------------------------------------------------------

//Recall that in Fortran, untyped variables starting with
//an I, J, K, L, M, or N are considered integers, while untyped variables
//starting with any other letter are considered reals.
TOKEN: {
  < #INT_IDENT: ( "i" | "j" | "k" | "l" | "m" | "n" | "I" | "J" | "K" | "L" | "M" | "N" ) >
}

TOKEN: {
  < #FLOAT_IDENT: ( ["a"-"h"] | ["o"-"z"] | ["A"-"H"] | ["O"-"Z"] ) >
}

//basically an equals sign with optional whitespace on either side
TOKEN: {
  < EQ: <OPT_WS> "=" <OPT_WS> >
}

//Fortran has a non-C like way of declaring character arrays so we
//need to watch out for variables like "character *6 charA" (character
//array of length 6.  This token handles those.
TOKEN: {
  < #CHAR_VARIABLE: ( 
    <OPT_WS>
    <VARIABLE> " *" ( <UNSIGNED_DIGIT> )+
    <OPT_WS> 
  ) >
}

//this token allows integers or variables.  It is meant for use in the
//math functions
TOKEN: {
  < #MATH_INT_VAR: (
    <OPT_WS> (
      ( <DIGIT> )+ | <VARIABLE>
    )
    <OPT_WS>
  ) >
}

//This token is meant for math functions that will only accept
//a floating point or variables
TOKEN: {
  <#MATH_FLOAT_VAR: (
    <OPT_WS> (
      <FLOATING_POINT> | <VARIABLE>
     ) 
    <OPT_WS>
  ) >
}

//this is sort of a "catch-all" to allow using floating points, integers,
//or variables in a Fortran math expression.  It allows a single floating
//point number or a single integer or a single "variable"
TOKEN: {
  <#MATH_VAR: (
    <OPT_WS> (
      <MATH_FLOAT_VAR> | <MATH_INT_VAR>
     ) 
    <OPT_WS>
  ) >
}

//~----------------------------------------------------------------------------
//FORTRAN MATH ROUTINES
//~----------------------------------------------------------------------------

//absolute function
TOKEN: {
  < FORTRAN_ABS: (
    <OPT_WS>
    ( "abs" | "iabs" ) <LPAREN> <MATH_VAR> <RPAREN>
  ) >
}

//square root function
TOKEN: {
  < FORTRAN_SQRT: (
    <OPT_WS>
    "sqrt" <LPAREN> <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//sine function
TOKEN: {
  < FORTRAN_SIN: (
    <OPT_WS>
    "sin" <LPAREN> <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//arcsine function
TOKEN: {
  < FORTRAN_ASIN: (
    <OPT_WS>
    "asin" <LPAREN> <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//cosine function
TOKEN: {
  < FORTRAN_COS: (
    <OPT_WS>
    "cos" <LPAREN> <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//arccosine function
TOKEN: {
  < FORTRAN_ACOS: (
    <OPT_WS>
    "acos" <LPAREN> <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//tangent function
TOKEN: {
  < FORTRAN_TAN: (
    <OPT_WS>
    "tan" <LPAREN> <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//arctangent function
TOKEN: {
  < FORTRAN_ATAN: (
    <OPT_WS>
    "atan" <LPAREN> <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//log function
TOKEN: {
  < FORTRAN_LOG: (
    <OPT_WS>
    "log" <LPAREN> <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//Euler's (exp) function
TOKEN: {
  < FORTRAN_EXP: (
    <OPT_WS>
    "exp" <LPAREN> <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//Handles the Fortran real() function.
TOKEN: {
  < FORTRAN_FLOAT_FUN: (
    <OPT_WS>
    ( "float" | "real" ) <LPAREN> <MATH_INT_VAR> <RPAREN>
  ) >
}

//converts a floating point to an integer by truncating
TOKEN: {
  < FORTRAN_TRUNC_FUN: (
    <OPT_WS>
    "int" <LPAREN> <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//mod function
TOKEN: {
  < FORTRAN_MOD_FUN: (
    <OPT_WS>
    "mod" <LPAREN> <MATH_INT_VAR> "," <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//floor() function
TOKEN: {
  < FORTRAN_FLOOR_FUN: (
    <OPT_WS>
    "floor" <LPAREN> <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//fraction() function-I used the Java IEEERemainder for this one
TOKEN: {
  < FORTRAN_FRACTION_FUN: (
    <OPT_WS>
    "fraction" <LPAREN> <MATH_FLOAT_VAR> <RPAREN>
  ) >
}

//~----------------------------------------------------------------------------
// FORTRAN EXPRESSIONS
// These expression matches are extremely generous with
// allowing parentheses.  They will, in fact, allow invalid expressions
// However, both a Fortran compiler and a Java compiler should
// catch these expressions.
//~----------------------------------------------------------------------------

//math operators
TOKEN: {
  < #OPERATOR: (
    <OPT_WS> (
      "+"| "-"| "*"| "/"
    ) <OPT_WS> 
  ) >
}

//operands for math operators
TOKEN: {
  < #OPERAND: (
    <OPT_WS> (
      <VARIABLE> | <DIGIT> | <FLOATING_POINT>
    ) <OPT_WS>
  ) >
}
    
//essentially: a simple math expression consisting of at least two operands
//and one operator, surrounded (optionally) by parentheses
TOKEN: {
  < #SIMPLE_EXPRESSION: (
    ( <LPAREN> )?
    <OPERAND> ( <OPERATOR> <OPERAND> )+
    ( <RPAREN> )?
  ) >
}

TOKEN: {
  <#NESTED_EXPRESSION: (
    ( <LPAREN> )? ( <OPERAND> <OPERATOR> <LPAREN> )*
    <SIMPLE_EXPRESSION>
    ( <RPAREN> <OPERATOR> <OPERAND> )* ( <RPAREN> )?
  ) >
}

//the full set of expressions
TOKEN: {
  <FORTRAN_EXPRESSION: (
    ( ( <VARIABLE> <EQ> ) | <LPAREN> )?
    ( 
      ( <SIMPLE_EXPRESSION> | <NESTED_EXPRESSION> )
      ( <OPERATOR> 
        ( <SIMPLE_EXPRESSION> | <NESTED_EXPRESSION> ) 
      )* 
    )
    ( <RPAREN> )?
    <OPT_WS>
  ) >
}

//~----------------------------------------------------------------------------
// FORTRAN CONDITIONALS
//~----------------------------------------------------------------------------

//one line if statement
TOKEN: {
  < SINGLE_IF: (
    <OPT_WS>
    "if" <LPAREN> <OPERAND> ( ".lt." | ".gt." ) <OPERAND> <RPAREN>
  ) >
}

//start of multi line if statement
TOKEN: {
  < START_MULTI_IF: (
    <OPT_WS>
    "if" <LPAREN> <OPERAND> ( ".lt." | ".gt." ) 
    <OPERAND> <RPAREN> "then" 
    <OPT_WS>
  ) >
}

//end of multi-line if statement
TOKEN: {
  < END_IF: (
    <OPT_WS> "endif" <OPT_WS> 
   ) >
}

//~----------------------------------------------------------------------------
// FORTRAN VARIABLE ASSIGNMENTS
//~----------------------------------------------------------------------------
TOKEN: {
  <VAR_ASSIGN: (
    <VARIABLE> <EQ> <OPERAND>
  ) >
}

//~----------------------------------------------------------------------------
//FORTRAN VARIABLE TYPES
//~----------------------------------------------------------------------------

//integer variable
TOKEN : {
  < FORTRAN_INT: ( 
    <OPT_WS>
    ( "integer " | <INT_IDENT> ) 
    ( 
      <ARRAY_VARIABLE> | ( <VARIABLE> ( <EQ> ( <DIGIT> )+ )? ) 
    ) 
    (  
      "," ( <ARRAY_VARIABLE> | ( <VARIABLE> ( <EQ> ( <DIGIT> )+ )? ) )  
    )* 
    <OPT_WS>
  ) >
}

//floating point variable
TOKEN : {
  < FORTRAN_REAL: (
    <OPT_WS> 
    ( "real " | <FLOAT_IDENT> )
    ( 
      <ARRAY_VARIABLE> | ( <VARIABLE> ( <EQ> ( <FLOATING_POINT> )+ )? ) 
    ) 
    (  
      "," ( <ARRAY_VARIABLE> | ( <VARIABLE> ( <EQ> ( <FLOATING_POINT> )+ )? ) )  
    )*
    <OPT_WS> 
  ) >
}

//double-precision floating point variable
TOKEN : {
  < FORTRAN_DOUBLE: (
    <OPT_WS> 
    "double precision" 
    ( 
      <ARRAY_VARIABLE> | ( <VARIABLE> ( <EQ> ( <FLOATING_POINT> )+ )? ) 
    ) 
    (  
      "," ( <ARRAY_VARIABLE> | ( <VARIABLE> ( <EQ> ( <FLOATING_POINT> )+ )? ) )  
    )* 
    <OPT_WS> 
  ) >
}

//boolean (i.e. logical) variable
TOKEN : {
  < FORTRAN_LOGICAL: (
    <OPT_WS> 
    "logical " 
    ( 
      <ARRAY_VARIABLE> | ( <VARIABLE> ( <EQ> ( <BOOL_CONST> )+ )? ) 
    ) 
    (  
      "," ( <ARRAY_VARIABLE> | ( <VARIABLE> ( <EQ> ( <BOOL_CONST> )+ )? ) )  
    )* 
    <OPT_WS> 
  ) >
}

//character variable where each char array length is specified directly
TOKEN : {
  < FORTRAN_CHAR_1: (
    <OPT_WS> 
    "character " <CHAR_VARIABLE> ( 
      "," <CHAR_VARIABLE> 
    )*
    <OPT_WS> 
  ) >
}

//character variable where the length is specified at the beginning of the 
//array declaration
TOKEN: {
  < FORTRAN_CHAR_2: (
    <OPT_WS> 
    "character" <ONE_PLUS_WS> "*" ( <UNSIGNED_DIGIT> )+ 
    <ONE_PLUS_WS> <VARIABLE> ( 
      "," <VARIABLE> )*
    <OPT_WS> 
    ) >
}

/**
 * This method goes through a line of Fortran code, converting it to Java.
 * It also has the ability to test the parser by checking the standalone
 * quality and bringing up a command line prompt if it should run 
 * standalone.
 * 
 * @return The converted Fortran-to-Java code.
 */
String parseCode(  ) : {
  String codeLine = "";
}
{ 
  {
    if( standalone ) {
      /*System.out.println( "Please type in a line of Fortran code " +
        "or ^D to quit:\n" );*/
    }
  }
  ( codeLine = convertFortranToJava(  ) <LINE_END>{
      //a newline ends the expansion, and the parser expects one, so tack it on
      //print the parsed expression
      if( standalone ) {
        System.out.print( codeLine );
        /*System.out.println(  );
        System.out.println( "Please type in another line of Fortran code or ^D to quit:" );
        System.out.println(  );*/
      }
    }
  )*
  {
    return codeLine;
  }
  <EOF>
}

/**
 * This method actually converts the line of Fortran to Java.
 * 
 * @return A line of code converted from Fortran to Java. 
 */
String convertFortranToJava(  ) : {
  StringBuffer fCode = new StringBuffer(  );
  String fToken;
}
{
  //this stuff should be unnecessary
  /*fToken = convertFortranTokens(  ) {
    fCode.append( fToken );
    fCode.append( " " );
  }*/
  //the WHITESPACE stuff here should be unnecessary-all the tokens should 
  //have the OPT_WS before and after, so that they are able to have 
  //arbitrary whitespace
  ( /*( ( <WHITESPACE> )* )*/ fToken = convertFortranTokens(  ) {
    fCode.append( fToken );
    fCode.append( " " );
  }
  )*

  {
    if( appendSemiColon ) {
      appendSemiColon = false;
      return fCode.toString(  ) + ";\n";
    } else {
      return fCode.toString(  ) + "\n";
    }
  }
}

/**
 * This method goes through the tokens defined earlier in this file and 
 * changes each to a Java token.
 * 
 * @return The converted token.
 */
String convertFortranTokens(  ) : {
  Token t;
  String s;
  StringBuffer buffer;
  String[] tokenList;
}
{
  //matched a comment
  t = <FORTRAN_COMMENT> {
    s = t.image;
    //we know that the comment 'C' is always in the first column
    s = s.substring( 1, s.length(  ) );
    s = "//" + s;
    return s;
  }
|
  //some kind of math expression
  t = <FORTRAN_EXPRESSION> {
    return t.image;
  }
|
  //variable assignment
  t = <VAR_ASSIGN> {
    appendSemiColon = true;
    return t.image;
  }
|
  //single line if
  t = <SINGLE_IF> {
    appendSemiColon = true;
    return t.image.replaceAll( ".lt.", "<" ).replaceAll( ".gt.", ">" );
  }
|
  //start of multi line if
  t = <START_MULTI_IF> {
    return t.image.replaceAll( ".lt.", "<" )
                          .replaceAll( ".gt.", ">" )
                          .replaceAll( "then", "{");
  }
|
  //end if
  t = <END_IF> {
    return t.image.replaceAll( "endif", "}" );
  }
|
  //matched the absolute function
  t = <FORTRAN_ABS> {
    s = t.image;
    if( s.indexOf( "iabs" ) >= 0 ) {
      s.replaceAll( "iabs", "Math.abs" );
    } else {
      s.replaceAll( "abs", "Math.abs" );
    }
    
    return s;
  }
|
  //square root function
  t = <FORTRAN_SQRT> {
    return convertMath( t.image, "sqrt" );
  }
|
  //sine function
  t = <FORTRAN_SIN> {
    return convertMath( t.image, "sin" );
  }
|
  //arcsine function
  t = <FORTRAN_ASIN> {
    return convertMath( t.image, "asin" );
  }
|
  //cosine function
  t = <FORTRAN_COS> {
    return convertMath( t.image, "cos" );
  }
|
  //arccosine function
  t = <FORTRAN_ACOS> {
    return convertMath( t.image, "acos" );
  }
|
  //tangent function
  t = <FORTRAN_TAN> {
    return convertMath( t.image, "tan" );
  }
|
  //tangent function
  t = <FORTRAN_ATAN> {
    return convertMath( t.image, "atan" );
  }
|
  //log function
  t = <FORTRAN_LOG> {
    return convertMath( t.image, "log" );
  }
|
  //exp function
  t = <FORTRAN_EXP> {
    return convertMath( t.image, "exp" );
  }
|
  //floor function
  t = <FORTRAN_FLOOR_FUN> {
    return convertMath( t.image, "floor" );
  }
|
  //fraction function
  t = <FORTRAN_FRACTION_FUN> {
    //based upon the Javadocs for the Math.IEEERemainder() method,
    //this will compute the remainder of whatever the argument was
    //divided by 1 (e.g. 3.14 / 1, which would give 0.14 as a remainder
    s = t.image;
    s = s.replaceAll( "fraction", "" ).replaceAll( "\\(", "").replaceAll( "\\)", "");
    s = "Math.IEERemainder( " + s.trim(  ) + ", 1)";

    return s;
  }
| 
  //matched the float() function
  t = <FORTRAN_FLOAT_FUN> {
    s = t.image;
    if( s.indexOf( "float" ) >= 0 ) {
      s = s.replaceAll( "float", "" );
    } else {
      s = s.replaceAll( "real", "" );
    }
    
    s = "Float.parseFloat" + s;
    
    return s;
  }
|
  //matched the truncate function
  t = <FORTRAN_TRUNC_FUN> {
    s = t.image.replaceAll( "int", "" );
    
    s = "new Float" + s + ".intValue()";
    
    return s;
  }
|
  //matched the mod() function
  t = <FORTRAN_MOD_FUN> {
    s = t.image;
    s = s.replaceAll( "mod", "" ).replaceAll( "\\)", "" ).replaceAll( "\\(", "" );
    s = s.replaceAll( ",", " % " );
    return s;
  }
|
  //matched a double-precision floating point
  t = <FORTRAN_DOUBLE> {
    t.image = t.image.replaceAll( "double precision", "" );
    return convertToJavaStyle( t.image, "double" );
  }
|
  //matched an integer
  t = <FORTRAN_INT> {
    t.image = t.image.replaceAll( "integer", "" );
    return convertToJavaStyle( t.image, "int" );
  }
|
  //matched a floating point
  t = <FORTRAN_REAL> {
    t.image = t.image.replaceAll( "real", "" );
    return convertToJavaStyle( t.image, "float" );
  }
|
  //matched a boolean
  t = <FORTRAN_LOGICAL> {
    t.image = t.image.replaceAll( "logical", "" )
                              .replaceAll( ".true.", "true" )
                              .replaceAll( ".false.", "false" );
    return convertToJavaStyle( t.image, "boolean" );
  }
|
  //matched a character or character array where each variable is
  //explicitly given a length
  t = <FORTRAN_CHAR_1> {
    appendSemiColon = true;
    s = t.image;
    buffer = new StringBuffer( "char " );
    
    //dump the "character" stuff
    s = ( s.replaceAll( "character", "" ) ).trim(  );
    //now we will create character arrays for each of the Fortran
    //character declarations.  The assumption is that we will have a 
    //comma delimited list of name, number pairs at this point
    tokenList = s.split( "\\s+|\\s*,\\s*" );
    
    for( int i = 0; i < tokenList.length; i++ ) {
      if( ( i % 2 )  == 0 ) {
        //we found a variable name, so append it and the array declaration
        buffer.append( tokenList[i] );
        buffer.append( " = new char[" );
      } else {
        //we found the array dimension, so append that
        buffer.append( tokenList[i].replaceAll( "\\*", "" ) );
        buffer.append( "]" );
        
        //if we haven't reached the end of our token list, append a 
        //comma
        if( i < tokenList.length - 2 ) {
                buffer.append( "," );
        }
      }
    }
    
    return buffer.toString();
  }
|
  //matched a character or character array where each variable is
  //given a length specified in the character *n declaration
  t = <FORTRAN_CHAR_2> {
    appendSemiColon = true;
    s = t.image;
    buffer = new StringBuffer( "char " );
    
    //dump the "character" stuff
    s = ( s.replaceAll( "character", "" ) ).trim(  );
    //break the declarations up by comma and space.  The first token is
    //the number to use for length
    
    tokenList = s.split( "\\s+|\\s*,\\s*" );
    String length = tokenList[0].replaceAll( "\\*", "" );
    
    for( int i = 1; i < tokenList.length; i++ ) {
      buffer.append( tokenList[i] );
      buffer.append( " = new char[" );
      //first element is array length
      buffer.append( length );
      buffer.append( "]" );
      
      if( i < tokenList.length - 1 ) {
        buffer.append( "," );
      }
    }
    
    return buffer.toString();
  }
|
  //matched a digit
  t = <DIGIT> {
    return t.image;
  }
|
  //matched a float
  t = <FLOATING_POINT> {
    return t.image;
  }
|
  //matched a String
  t = <STRING> {
    //replace Fortran's double single quotes with a backslash quote
    return t.image.replaceAll( "''", "\\\\\"");
  }
|
  //found an empty line, so spit it back
  t = <ONE_PLUS_WS> {
    return t.image;
  }
}
