options{USER_TOKEN_MANAGER=true;
        STATIC=false;
        DEBUG_PARSER=false;
        BUILD_TOKEN_MANAGER=false;
       }

PARSER_BEGIN( Fcvrt)
/*
 * File:  Fcvrt.java 
 *             
 * Copyright (C) 2004, Ruth Mikkelson
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
 *
 * Contact : Ruth Mikkelson <mikkelsonr@uwstout.edu>
 *           Department of Mathematics, Statistics and Computer Science
 *           University of Wisconsin-Stout
 *           Menomonie, WI 54751, USA
 *
 * This work was supported by the Intense Pulsed Neutron Source Division
 * of Argonne National Laboratory, Argonne, IL 60439-4845, USA.
 * This work was supported by the National Science Foundation under
 * grant number DMR-0218882
 *
 * For further information, see <http://www.pns.anl.gov/ISAW/>
 *
 * This java file was created from the file FortJ2.jj using JavaCC. See header
 * for information
 * Modified:
 *
 * $Log: Fcvrt.java,v $
 */

 package Command.JavaCC.Fortran;
 import java.util.*;
 import Command.JavaCC.Fortran.*;
 /**
   *  Constructor
   *  The main method invokes the specialized FortranTokenManager. 
   */
public class Fcvrt {
   private static final int indentDelta = 2;
   ListHandler Variable=new ListHandler();
   String CurrentMethodName = null;
   int mode =0;   //0 start,1-sub/fxn line,2-declarations,3-statements,4-END->0
   boolean lastStatementSimple = true;
   String doLabels=";";
   String Parameters=";";
   boolean threwException = false;
   int thrVarnum=0;
   public String filename = null;
   boolean Finished = false;
   int indent =2;
   String buff = null;
   public String Res ="";
  /**
    *  Program that invokes this translator.
    * @param  args[0]  the filename of a file that contains a [sequence of]
    *                  subroutine[s] or function[s]
    * @return nothing but each subroutine and function will be translated
    *          to a different java file. The filename corresponds to the 
    *          subroutine or function name.
    */
  public static void main( String args[]){
      Fcvrt parser;
   
      
      parser = new Fcvrt(new FortranTokenManager(args[0]));
      try{
         parser.filename = new java.io.File(args[0]).getCanonicalPath();
      }catch(Exception s3){
         parser.filename ="/x.f";
      }
   
    try {

     
      System.out.println("Result=\n"+parser.start());
      System.out.println("Java Parser Version 1.0.2:  Java program parsed successfully.");

    } catch (ParseException e) {
      System.out.println("ERROR REsult so far is \n"+parser.Res);
      System.out.println("Java Parser Version 1.0.2:  Encountered errors during parse."+
       e.toString());
      e.printStackTrace();

    }
  }
  
  /**
    *  All assignment statements go through this routine
    *  @param  varname  the variable name
    *  @param A list of parameters in String form
    *  @param expression the String form of an expression to be assigned to
    *                    the variable 
    * @return a String representing the Java form of the statement
    */
  private String makeUpAssignmentStatement( String varname, String[] params, 
                                                    String expression) throws ParseException
                   {
    String s=varname;
    if( varname.equals( CurrentMethodName))
       s +="result";
    
    if( params !=null)
      if(params.length >0){
         if( !checkVariable( varname, params.length))
           throw new ParseException("Arrays must be declared before assignment");
         for(int i=0;i<params.length;i++){
           s += "[(int)("+params[i]+"-"+Offset(varname,i)+")]";
         }
      }
    if( !checkVariable( varname, -1))
       addVariable( varname, "DIMENSION",2, params);
    VariableInfo vbInf = (VariableInfo)Variable.get( varname);
    String dt = vbInf.DataType;
    if( dt == null) dt = "XX";
    if( dt.length()<1) dt ="XX";
    if( "int;float;long;byte;String;double;".indexOf(dt)<0)
      if( "IJKLMNO".indexOf( varname.toUpperCase().charAt(0))>=0)
         dt = "int";
      else
         dt = "float";
         
    return s+= "=("+dt+")"+expression+";\n";
   }
  /**
    *  @param name  the variable name
    *  @param DataType the data type of the variable(null,int,float, etc)
    *  @param location  0-common;1-parameter;2-local,3-external fxn
    *  @param Parameters  The list of parameters in string form
    */
  private void addVariable( String name, String DataType,int location, 
                   String[]Parameters){
     VariableInfo vbInf = (VariableInfo) Variable.get(name);
     if( vbInf == null)
        Variable.add(new VariableInfo( DataType, location,Parameters),name);
     else{
        if( vbInf.location < 0)
           vbInf.location = location;
        if(location > 2)
           vbInf.location = location; //External a
        if( vbInf.DataType == null)
            vbInf.DataType = DataType;
        if( ";int;float;double;long;short;".indexOf(";"+vbInf.DataType+";")<0)
            vbInf.DataType=DataType;
        if( vbInf.Parameters == null)
            vbInf.Parameters =Parameters;

     }

  }
  /**
    *  @param name is the possible variable name
    *  @numParameters  the number of dimensions the variable has, 0 and -1 OK
    *  @return the data type of the variable(0-int,1-float,2 -Double, -1 implicit
    */
  private boolean checkVariable( String name, int numParameters){
     VariableInfo vinf= (VariableInfo)Variable.get( name);
     if( vinf == null)
        return false;
     if( numParameters < 0) 
        return true;
     if( vinf.Parameters == null)
        if( numParameters == 0)
           return true;
        else
           return false;
     if( vinf.Parameters.length == numParameters)
        return true;
     return false;

  }
  private void SetDataTypes( ListHandler VarList){
     for( int i=0; i< VarList.size(); i++){
        VariableInfo vbInf =(VariableInfo)VarList.getValue(i);
        if( vbInf.location < 0)
             vbInf.location = 2;
        if( ";int;float;double;long;short;byte;boolean;String;".indexOf(
                   ";"+vbInf.DataType+";")<0){

           String name = VarList.getName(i).toUpperCase();
           if( "IJKLMNO".indexOf(name.charAt(0))<0)
             vbInf.DataType ="float";
           else
             vbInf.DataType = "int";
           
        }

     }


  }

 private String Offset( String ArrayVarName, int dim){

    VariableInfo vbInf =(VariableInfo)Variable.get( ArrayVarName);
    if( vbInf == null)
      return "0";
    if( vbInf.Parameters == null)
       return "0";
    if( dim < 0)
       return "0";
    if( dim >= vbInf.Parameters.length)
       return "0";
    //if( vbInf.location ==1)
    //   return "0";
    String S = vbInf.Parameters[dim];
    if( S.indexOf(':') < 0)
       return "1";
    return S.substring(0,S.indexOf(':'));
    
 }
 public String getDefaultInitValue(String DataType,String[] Parameters)
             throws ParseException{
   if( Parameters != null)
       if( Parameters.length > 0)
          return "null";
   if( DataType.equals("String"))
      return "null";
   if( DataType.equals("int"))
      return "0";
   else if( DataType.equals("float"))
      return "0f";
   else if( DataType.equals("double"))
      return "0.0";
   else if( DataType.equals("long"))
      return "(long)0";
   else if( DataType.equals("short"))
      return "(short)0";
   else if( DataType.equals("byte"))
      return "(byte)0";
   else if( DataType.equals("boolean"))
      return "true";
   else
     throw new ParseException( DataType+" is not supported");
 }

 private String Pretty( int indentLevel, String S){
   if( S == null)
      return "";
   if( S.trim().length()<1)
      return "";
   String Res ="";
   if( buff == null){
     char[] buff1 = new char[indentDelta];
     Arrays.fill( buff1,' ');
     buff= new String( buff1);
   }
   for(int i=0;i<indentLevel; i++)
     Res +=buff;
   int i = S.indexOf("\n");
   if( i >=0)
     if( Res.length() +i < 80)
        return Res + S.substring(0,i+1)+ Pretty(indentLevel+1,S.substring(i+1));
   
    int j = -1;
    boolean quotemode = false;
    for( int k = 0; (k < S.length())&&(k+Res.length()<80);  k++)
       if( "\"+-*/^()[]=".indexOf(S.charAt( k))>=0)
          if( S.charAt(k) =='\"')
             quotemode = !quotemode;
          else if( quotemode){}
          else if( k ==S.length()-1)
            j=k;
          else if("+-*/=".indexOf(S.charAt(k+1))> 0)
            {}
           else
              j = k;
    if( j < 0)
       return Res +S;
    return Res + S.substring(0,j+1)+"\n"+Pretty(indentLevel+1, S.substring(j+1));
 }//Pretty
}
class VariableInfo{
  public String DataType;
  public int location;
  public String[] Parameters;
  public VariableInfo( String DataType, int location, String[] Parameters){
     this.DataType = DataType;
     this.location  = location;
     this.Parameters = Parameters;
  }
}
PARSER_END(Fcvrt)
String start():{
   String s1="";
         // s2="";
   Token t=null;
   String errStart,
         errEnd;
   int oldIndentLevel = indent;

}{
  (t=<COMMENT><EOLN>{
     Res+= "//"+t.image+"\n";
    }
   | t=<LABEL> s1=statement( Res )
     { 
        errStart ="";
       errEnd ="";
       if(threwException){
          errStart ="try{\n";
          errEnd = "}catch(Throwable Thrvar"+thrVarnum+"){\n";
          errEnd += "  return new ErrorString( Thrvar"+thrVarnum+");\n}\n";
          threwException = false;
          thrVarnum++;
          Res += Pretty( oldIndentLevel, errStart);
          Res += Pretty(oldIndentLevel+1, s1+"\n");
          Res += Pretty( oldIndentLevel, errEnd);
          
       }
       else 
          Res += Pretty(oldIndentLevel,errStart+s1+"\n"+errEnd);
       if( lastStatementSimple){
       String lbl = t.image.trim();
       for( int k= doLabels.indexOf(";"+lbl+";");k>=0;
            k= doLabels.indexOf(";"+lbl+";",k+2)){
            Res += "}\n";
            indent--;
       }
      
       //Res+= Pretty(oldIndentLevel,errStart+s1+"\n"+errEnd);
       oldIndentLevel = indent;
       if( Finished) 
          return Res;
       }
      }

   | s1=statement( Res ) {
       errStart ="";
      errEnd ="";
       if(threwException){
          errStart ="try{\n";
          errEnd = "}catch(Throwable Thrvar"+thrVarnum+"){\n";
          errEnd += "  return new ErrorString( Thrvar"+thrVarnum+");\n}\n";
          threwException = false;
          thrVarnum++;
          
          Res += Pretty( oldIndentLevel, errStart);
          Res += Pretty(oldIndentLevel+1, s1+"\n");
          Res += Pretty( oldIndentLevel, errEnd);
         
       }
      else 
          Res+= Pretty(oldIndentLevel,errStart+s1+errEnd);
       oldIndentLevel = indent;
      if( Finished)
        return Res;
     }


   )*
  <EOF>
  { 
    return Res;
  }
}
String statement( String Res):{
String s1;//s2="",s3="";
String[] params = null;
Token t;
 //String[] ss=null;
  
  lastStatementSimple = true;

 }
 {
   <SUBROUTINE> s1= RestofMethod("SUROUTINE") <EOLN>{
       return s1;
    }
   |<FUNCTION>  s1=RestofMethod("FUNCTION")  <EOLN>{
       return s1;
    }
   |<INTEGER>  s1=RestofDeclare("int") <EOLN>{
       return s1;
    }
   |<REAL>   s1=RestofDeclare("float") <EOLN>{
       return s1;
    }
   |<CHARACTER>  s1= RestofDeclare("String") <EOLN>{
       return s1;
    }
   |<LOGICAL>  s1=RestofDeclare("boolean") <EOLN>{
       return s1;
    }
   |<EXTERNAL>  s1=RestofExternal()<EOLN>{
       return s1;
    }
   |<DIMENSION>  s1=RestofDeclare("")<EOLN>{
       return s1;
    }
   |<CONTINUE>  s1= RestofExpression("CONTINUE") {
       return s1;
    }
   |<ELSE>  s1=RestofExpression("ELSE"){
       return s1;
    }
   |<ENDIF>  s1=RestofExpression("ENDIF") {
       return s1;
    }
   |<IF> [params=ExpressionList()]  s1=RestofIf(0, params){
        return s1;
    } 
   |<ELSEIF> [params=ExpressionList()]  s1=RestofIf(1,params)
     { if( !lastStatementSimple)
              return  "}else "+s1+"\n";
       else
         return s1;
      }
   |<EOLN>{
      return "\n";
   }
   |<DO> s1=RestofDo() <EOLN>{
       return s1;
    }
   |<CALL>  s1 = RestofCall() <EOLN>{
        return s1;

   }
   | <END> s1=RestofEnd( Res ,"END") {
       return s1;
   }
   | <RETURN> s1= RestofReturn() {
      return s1;
    }
   |t=<IDENTIFIER> [params=ExpressionList()]<EQUALS> s1=Expression("")<EOLN>
       {  
          if( mode <1)  throw new ParseException("Cannot have a statement outside of a sub");
          mode = 3;
         if(params != null)
           if( !checkVariable(t.image.toUpperCase(),params.length))
              throw new ParseException("Cannot assign value to function");
         if( !checkVariable( t.image.toUpperCase(),-1))
              addVariable(t.image.toUpperCase(),"",2,null);
         return makeUpAssignmentStatement(t.image.toUpperCase() , params , s1);

       }
    
   
 }
String RestofMethod( String name):{
  String s;//s2,s1=null;
  String[] params=null;
}{
     [params=ExpressionList()]<EQUALS> s=Expression("")
       {  
          if( mode <1)  throw new ParseException("Cannot have a statement outside of a sub");
          mode = 3;
         return makeUpAssignmentStatement(name , params , s);

       }


   | s=PossVarName() [params=ExpressionList()]
     {
        if( mode >1) throw new ParseException("Cannot have a sub/Funct line inside a body");
        mode = 2;
        CurrentMethodName = s.toUpperCase();
        if(name.equals("FUNCTION"))
            addVariable(CurrentMethodName,"DIMENSION",1, null);
        if(params != null)
          for( int i=0; i<params.length;i++){
             while( params[i].startsWith("("))
               params[i]=params[i].substring(1);

             while( params[i].endsWith(")"))
               params[i]=params[i].substring(0,params[i].length()-1);
             addVariable( params[i], "dimension",1,null);
             Parameters +=params[i]+";";
          }
        return  "";


     }

      
}

/** Follows Declaration lines 
*/
String RestofDeclare( String name):{
 //Token t1=null,t2=null; 
 String s,s1=null,s2=null,s3="";
 
 //int ndims = -1;
 String[] params=null,params1=null; 
}{
     [params=ExpressionList()]<EQUALS> s=Expression("")
       {  
          if( mode <1)  throw new ParseException("Cannot have a statement outside of a sub");
          mode = 3;
          if( params != null)
            if( !checkVariable( name,params.length))
               throw new ParseException("Array Variable "+name+" is not correctly declared");
            else{}
          else 
             addVariable( name.toUpperCase(),"DIMENSION",-1,params); 
          if( name.equals("int") )
             return makeUpAssignmentStatement("INTEGER", params, s);
          else if( name.equals("float"))
             return makeUpAssignmentStatement("REAL", params, s);
          else if( name.equals("boolean"))
             return makeUpAssignmentStatement("LOGICAL", params, s);
          else
             return makeUpAssignmentStatement("DIMENSION", params, s);
       }
     
    | s1=PossVarName() [s2= PossVarName()][params =ArgList()] 
       (<COMMA> s3=PossVarName() [params1=ArgList()]
          {
            if( checkVariable( s3,-1))
               addVariable(s3,name,-1,params1);
            else
               addVariable( s3,name,2,params1);
            params1 = null;
          }
        )*
       {  if( s2 == null){
          if( mode >2) throw new ParseException("Cannot declare after statements");
          mode = 2;
          addVariable(s1,name,-1,params);
          return "";      
         }
         if( !s1.equals("FUNCTION"))
            throw new ParseException(" Must Be a function here");
         addVariable( s2.toUpperCase(), name,2, null);
         CurrentMethodName = s2.toUpperCase();
         
         if( params != null)
          if( params.length >0)
         for( int i = 0; i< params.length; i++){
             while( params[i].startsWith("("))
               params[i]=params[i].substring(1);

             while( params[i].endsWith(")"))
               params[i]=params[i].substring(0,params[i].length()-1);
             addVariable( params[i], "dimension",1,null);
             Parameters += params[i]+";";
          }
          return "";   
        }


}


String RestofExternal():{
 //Token t1=null,t2=null;
 String s,s1=null,s3="";//s2="";
 //String Res="";
 String[] params=null;//params1=null; 
 VariableInfo vbInf;
}{
     [params=ExpressionList()]<EQUALS> s=Expression("")
       {  
          if( mode <1)  throw new ParseException("Cannot have a statement outside of a sub");
          mode = 3;
          
          return makeUpAssignmentStatement("EXTERNAL", params, s);
       }
     
    | s1=PossVarName() 
       (<COMMA> s3=PossVarName() 
         {
          vbInf = (VariableInfo) Variable.get(s3);
          if( vbInf == null)
             Variable.add(new VariableInfo( "DIMENSION", 3,null),s3);
          else
             vbInf.location = 3;
         }
       )*
       {  
         vbInf = (VariableInfo) Variable.get(s1);
          if( vbInf == null)
             Variable.add(new VariableInfo( "DIMENSION", 3,null),s1);
          else
             vbInf.location = 3;
          return "";          
        }
}
/**
  * This one must consume <EOLN>. Used only for CONTINUE, ELSE, and ENDIF
  */
String RestofExpression( String vname):{
//Token t1=null,t2=null;
 String s;//s1=null,s2="",s3="";
// String Res="";
 String[] params=null;//params1=null; 
}{
     [params=ExpressionList()]<EQUALS> s=Expression("")<EOLN>
       {  
          if( mode <1)  throw new ParseException("Cannot have a statement outside of a sub");
          mode = 3;
          return makeUpAssignmentStatement(vname, params, s);
       }
     
    | <EOLN>
       
       {  
         vname = vname.toUpperCase();
         if( vname.equals("CONTINUE"))
             return "\n";
         else if( vname.equals("ELSE"))
             return "} else {\n";
         else if( vname.equals("ENDIF")){
              indent--;
              return "}\n";
         }
             
        }
}

/**
  *
  *@param mode  0 if any if, 1 if struct if or 2 if one-line if
  */
String RestofIf( int Ifmode, String[] params):{
  String s;
  //String[] params1= null;
}{

     <EQUALS> s=Expression("")<EOLN>
       {  
          if( mode <1)  throw new ParseException("Cannot have a statement outside of a sub");
          mode = 3;
          return makeUpAssignmentStatement("IF", params, s);
       }
    |
     <THEN>  s=RestofThen(params,Ifmode) 
      { 
         return s;
       }
    | s= statement("")
     {
       if(! lastStatementSimple)
          throw new ParseException("1 line if's must be followed by simple statments");
       if(params == null)
            throw new ParseException("Cannot have empty conditional statement");
       if( params.length != 1)
           throw new ParseException("only one Conditional statement allowed");
       if( mode <1)  
           throw new ParseException("Cannot have a statement outside of a sub");

       lastStatementSimple = true;
       return "if(" + params[0]+")\n   "+s+"\n";
       

     }
}

String RestofThen( String[] params,int Ifmode):{
  String[] params1= null;
  String s;
}{
 <EOLN>{

         if(params == null)
           throw new ParseException("Cannot have empty conditional statement");
         if( params.length != 1)
           throw new ParseException("only one Conditional statement allowed");
         if( mode <1)  
                throw new ParseException("Cannot have a statement outside of a sub");
         if( Ifmode >1)
              throw new ParseException("Structured if statement not allowed");
         lastStatementSimple = false;
         indent++;
         return "if("+params[0]+"){\n";
         
  }
 |[params1=ExpressionList()] <EQUALS> s=Expression("")<EOLN>{
    
         if(params == null)
           throw new ParseException("Cannot have empty conditional statement");
         if( params.length != 1)
           throw new ParseException("only one Conditional statement allowed");
         if( mode <1)  
                throw new ParseException("Cannot have a statement outside of a sub");
         if( Ifmode >1)
              throw new ParseException("Structured if statement not allowed");
         return "if("+params[0]+")\n"+
                       makeUpAssignmentStatement("THEN",params1, s);
  }


}
String RestofDo():{
 Token t;
 String s,s1;//s2,s3=null,;
 String[] params = null;
}{
  [params=ExpressionList()] <EQUALS> s = Expression("")
       {  
          if( mode <1)  throw new ParseException("Cannot have a statement outside of a sub");
          mode = 3;
          return makeUpAssignmentStatement("DO", params, s);
       }
  | t=<INTNUM> s=PossVarName()  s1=RestofDoLabel( s){

       doLabels += t.image.trim()+";";
       indent++;
       return s1;
    }
}

String RestofDoLabel(String s):{
  String s1,s2,s3=null;
}{


   <EQUALS> s1=Expression("") <COMMA> s2=Expression("")
               [<COMMA> s3=Expression("")]{
     if( s3 == null)
         s3 = "1";
     
     if(!checkVariable(s,-1))
        addVariable( s, "DIMENSION",2, null);

     VariableInfo vbInf = (VariableInfo)Variable.get(s);
     String dt = vbInf.DataType;
     if(dt == null) 
       dt ="XX";
     else if( dt.length()<1)
       dt ="XX";
     if( "int;float;String;boolean;byte;".indexOf(dt) <0)
       if( "IJKLMNO".indexOf( s.toUpperCase().charAt(0))>=0)
          dt = "int";
       else
          dt = "float";
     return "for("+s+"=("+dt+")"+s1+";util.Sign("+s3+")*"+s+
               "<="+"util.Sign("+s3+")*"+s2+";"+s+"+=("+dt+")"+s3+"){\n";

  }|
  <LPAREN> s1=Expression("") <RPAREN>{
     if( !s.equals("WHILE"))
        throw new ParseException("Improper termination of Do statement");
     indent++;
     return "while("+s1+"){\n";
        

   }

}

String RestofCall():{
  String[] params = null;
  String s,s1;
}{
   [params=ExpressionList()] <EQUALS> s = Expression("")
       {  
          if( mode <1)  throw new ParseException("Cannot have a Call statement outside of a sub");
          mode = 3;
          return makeUpAssignmentStatement("CALL", params, s);
       }
    | s=PossVarName() [params = ExpressionList()]{
       s1=util.LocalInvokeFxnCode( s, params);
       if( s1 == null){
          s1 = util.OperatorInvokeFxnCode( s,params);
          threwException=true;
       
       }
      
      return s1+";\n";
     }
}

String RestofReturn():{
  String s;
  String[] params = null;
}{
    [params=ExpressionList()]<EQUALS> s=Expression("")<EOLN>
       {  
          if( mode <1)  throw new ParseException("Cannot have a statement outside of a sub");
          mode = 3;
          
          return makeUpAssignmentStatement("RETURN", params, s);
       }
   | <EOLN>
    {  return "return null;\n";
     }
}
String RestofEnd( String Res1 , String name):{
    String[] params = null;
    String s;
    Token t;
}{
  (t=<EOLN>|t=<EOF>){
        if( CurrentMethodName == null)
          throw new ParseException( "There is no sub or function name for code");
       filename = filename.replace( java.io.File.separatorChar,'/');
       int k7 = filename.lastIndexOf('/');
       if( k7 < 0) 
           k7 = filename.length();
       String outFile = filename.substring( 0, k7);

       outFile = outFile+"/"+CurrentMethodName+".java";
       java.io.PrintStream pstrm=null;
       try{
          pstrm = new java.io.PrintStream( 
                    new java.io.FileOutputStream(outFile));
       }catch( Exception sss){
          pstrm = System.out;
       }
       //----------- Header ------------------------
       pstrm.print("package ");
       String[] directs = util.dirList( filename, System.getProperty("java.class.path"));
       for(int kk=0; kk<directs.length; kk++){
         pstrm.print( directs[kk]);
         if( kk+1< directs.length)
           pstrm.print(".");
         else 
           pstrm.println(";");
       }

       pstrm.println("import java.util.*;\n");
       pstrm.println("import DataSetTools.operator.*;\n");
       pstrm.println("import Command.JavaCC.Fortran.*;\n");
       pstrm.println("import gov.anl.ipns.Util.SpecialStrings.*;\n"); 
       pstrm.println("public class "+CurrentMethodName+
                " implements Wrappable,HiddenOperator{\n");
       //---- Declare Parameters  --------
       SetDataTypes( Variable);
       int j = 1;
       for( int i = Parameters.indexOf(";",j+1); (i>=0)&&(i <= Parameters.length()-1);
                               i = Parameters.indexOf(";",i+1)){
          String namee = Parameters.substring( j,i);
          j  = i+1;
          VariableInfo vbInf = (VariableInfo)Variable.get(namee);
          if( vbInf != null)
          if( vbInf.location ==1){
              pstrm.print(buff+"public "+ vbInf.DataType);
              if(vbInf.Parameters != null)
                for(int  jj=0; jj<vbInf.Parameters.length; jj++)
                   pstrm.print("[]");
              pstrm.println(" "+namee+"="+
                     getDefaultInitValue(vbInf.DataType,vbInf.Parameters)+";\n");
          }
       }//Go thru each variable;

       pstrm.println(buff+"public Object calculate(){\n");

       //----- Declare local variables ---------------
      for( int i=0; i < Variable.size(); i++){
          VariableInfo vbInf = (VariableInfo)Variable.getValue(i);
          if( vbInf.location ==2){
              String vname = Variable.getName(i);
              if( vname.equals(CurrentMethodName)) //Common block variables need help
                 vname+="result";
              pstrm.print( buff+buff+vbInf.DataType);
              if(vbInf.Parameters != null)
                for(  j=0; j<vbInf.Parameters.length; j++)
                   pstrm.print("[]");
              pstrm.print(" "+vname);
              if( vbInf.Parameters != null){
                pstrm.print( "= new "+vbInf.DataType);
                for(  j=0; j<vbInf.Parameters.length; j++){
                   String S =vbInf.Parameters[j];
                   if( S.indexOf(':')>0)
                      S = S.substring(0, S.indexOf(':'));
                   pstrm.print("["+S+"-"+Offset(Variable.getName(i),j)+"+1]");
                }
                pstrm.println(";\n");
              }else
                pstrm.println("="+getDefaultInitValue(vbInf.DataType,
                           null)+";\n");
                      ;
          }
       }//Go thru each variable;
       pstrm.println(buff+buff+"//-------------- code ------------");
       pstrm.println( Res1);//Print the code
      if( ! checkVariable( CurrentMethodName, -1))
         pstrm.println(buff+buff+"return null;\n");
      else {
        VariableInfo vbInf =(VariableInfo)Variable.get( CurrentMethodName);
        String vname = CurrentMethodName+"result";
        if( vbInf.DataType.equals("String"))
           pstrm.println(buff+buff+"return "+vname+";\n");
        else if( (vbInf.Parameters != null) && (vbInf.Parameters.length >0))
            pstrm.println(buff+buff+"return "+vname+";\n");
        else{
          String sz = vbInf.DataType;
          if( sz.equals("int"))
             pstrm.println(buff+buff+"return new Integer("+vname+");\n");
          else if( sz.equals("float"))
             pstrm.println(buff+buff+"return new Float("+vname+");\n");
          else if( sz.equals("double"))
             pstrm.println(buff+buff+"return new Double("+vname+");\n");
          else if( sz.equals("long"))
             pstrm.println(buff+buff+"return new Long("+vname+");\n");
          else if( sz.equals("short"))
             pstrm.println(buff+buff+"return new Short("+vname+");\n");
          else if( sz.equals("byte"))
             pstrm.println(buff+buff+"return new Byte("+vname+");\n");
          else
             pstrm.println(buff+buff+"return null;\n");

        }
      }
      pstrm.println(buff+"}");

      pstrm.println(buff+"public String getCommand(){");
      pstrm.println(buff+buff+"return \""+CurrentMethodName+"\";}\n\n");
      pstrm.println(buff+"public String getDocumentation(){");
      pstrm.println(  buff+buff+"return \" Default Docs \";}");

     pstrm.println("}");


      //------Get ready for next sub-------
    try{
       pstrm.close();
       }catch( Exception sss){}
       mode=0;
       CurrentMethodName = null;
       Res ="";
       doLabels = ";";
       Parameters = ";";
       Variable = new ListHandler();
       if(t.kind == EOF)
          Finished = true;
       return "";
   
  }
  | [params=ExpressionList()] <EQUALS> s = Expression("") <EOLN>
       {  
          if( mode <1)  throw new ParseException("Cannot have a statement outside of a sub");
          mode = 3;
          return makeUpAssignmentStatement(name, params, s);
       }
  | <IF><EOLN>
     {indent--;
      return Pretty(indent, "}\n");
     }
}
/*
void RestOfParamList():{
 String t;
 }
 {
   <COMMA> t=PossVarName() RestOfParamList()
     {
      

     }|
   <RPAREN><EOLN>
 }
*/


/*------------------ Expression--------------------*/
String Expression(String prevOp):{
 Token t1 = null,
       t2 = null;
 String s,
        //s1="",
        s2="",
        s3,
        lparens="";
  
 }
 {
   LOOKAHEAD(2,(<LOGDOT>)<NOT>)
     <LOGDOT><NOT>(<DOT>|<LOGDOT>) s=Expression("")
       {  
         return "!"+s;
        }|
  
  
   s=NonAndOrExpression()
     (
      
      <LOGDOT> (t1=<AND>|t1=<OR>) (<LOGDOT>|<DOT>) 
         [<LOGDOT>t2=<NOT>(<DOT>|<LOGDOT>)]
          s3= NonAndOrExpression()
            { 
              if(t1.kind ==AND)
                s2+="&&";
              else
                s2+="||";
              if( t2 != null)
                s2 +='!';
              s2+=s3+")";
              lparens+="(";
           }   
     )*
     {
       return lparens+"("+s+s2+")";
     }
 }


String RestOfExpression( String prevOp):{
  Token t;
  String s;
         //lp = "",
        // rp = "";

 }
 {

   <LOGDOT> (t=<AND>|t=<OR>) (<LOGDOT>|<DOT>) s=Expression("AND")
     { if(prevOp.equals("AND")){
         //lp = "(";
         //rp=")";
       }
       if( t.kind == AND)
         return "&&"+s;

       else
         return "||"+s;

     }|
     {
       return "";

     }
 

 }

String NonAndOrExpression():{
 //Token t1=null,
 //      t2;
 String s,
        s1="";

   
 }
 {
   s=AlgExpression()   s1=RestOfNonAndOrExpression()
     {
       return "("+s+s1+")";

     }
 
 }


String RestOfNonAndOrExpression():{
 Token t1=null;
       //t2;
 String s;
       // s1="";
 
 }
 {
   LOOKAHEAD(2,<LOGDOT>(t1=<NE>|t1=<EQ>|t1=<LT>|t1=<LE>|t1=<GT>|t1=<GE>)) 
     <LOGDOT>(t1=<NE>|t1=<EQ>|t1=<LT>|t1=<LE>|t1=<GT>|t1=<GE>)
               (<DOT>|<LOGDOT>) 
              s=AlgExpression()
       {
         if(t1==null) 
           return "";

         else if( t1.kind==NE) 
           return ")!=("+s;

         else if( t1.kind==EQ) 
           return ")==("+s;

         else if( t1.kind==LT) 
           return ")<("+s;

         else if( t1.kind==LE) 
           return ")<=("+s;

         else if( t1.kind==GT) 
           return ")>("+s;

         else if( t1.kind==GE) 
           return ")>=("+s;

         else 
           return "";


       }|

    LOOKAHEAD(2, <LOGDOT> <TRUE>)
      <LOGDOT><TRUE>(<DOT>|<LOGDOT>){
         return "true";
     }
   |LOOKAHEAD(2, <LOGDOT> <FALSE>)
      <LOGDOT><FALSE>(<DOT>|<LOGDOT>){
         return "false";
     }

   |{
     return "";

   }
 
 
 }


String AlgExpression():{
 Token t=null;
       //t1;
 String s1,
        s2="";
 }
 {
   s1=termOfExpression() [(t=<PLUS>|t=<MINUS>) s2=AlgExpression()]
     {
       if( t== null)
         return s1;

       else if( t.kind ==PLUS)
         return s1+"+"+s2;

       else
         return s1+"-"+s2;
 
     }
 }


String termOfExpression():{
 Token t=null;
       //t1;
 String s,
        s2="",
        s3="";
 }
 {
   s=FactorOfExpression() 
       ((t=<PROD>|t=<DIVISION>)  s2=FactorOfExpression()
         {
           if( t.kind == PROD)
             s3+="*"+s2;

           else
             s3+= "/"+s2;

         }
       )*
   
         {
           if( t== null) 
             return s;

           else 
             return s+s3;

         }
 }


String FactorOfExpression():{
 Token //t=null,
       t1=null,
       t3=null;
 String s,
        s2="",
        s3,
        s4="";
  
 }
 {
   
   [t3=<MINUS>|t3=<PLUS>]  s=OneFactor() 
       (<POWER> [(t1=<PLUS>|t1=<MINUS>)] s3=OneFactor()
         { 
           s4="";
           if( t1!=null)
             if(t1.kind == MINUS) 
               s4="-"; 
           s2+= s4+s3;

         }

       )*
       { 
         String sign="";
         if( t3!=null) 
           if( t3.kind==MINUS)
             sign="-";

         if( s2=="") 
           return sign+s;
      
         return sign+"Math.pow("+s+","+s2+")"; 

       }
    
 }

// TODO  TRUE and FALSE, LOOKAHEAD does not work so must chain as usual
String OneFactor():{
 Token t1;
 String s,s1;
 String[] params = null;
 }
 { 
   s= PossVarName()[params=ExpressionList()]
     { 
       if( !checkVariable( s.toUpperCase(),-1))
         if(params == null){
          //String type ="float";
          //if( "IJKLMNO".indexOf( s.toUpperCase().charAt(0))>=0)
             //type ="int";
          addVariable( s.toUpperCase(), "dimension",-1,params);
          return s.toUpperCase();
         }else{ //Must be a function returns a number
           String dt = "float";
           if( "IJKLMN".indexOf( s.toUpperCase().charAt(0)) >=0)
              dt = "int";
           s1 = util.JavaInvokeIntrinsic(s,params);
           if( s1 == null)
              s1=util.LocalInvokeFxnCode(s,params);
           if( s1 == null){
              s1 = util.OperatorInvokeFxnCode(s, params);
              s1 ="((Number)("+s1+"))."+dt+"Value()";
             
              threwException = true;
           }
          return s1;
         }
      
        else{//could be external fxn
           VariableInfo vinf= (VariableInfo)Variable.get( s.toUpperCase());
          
           if((vinf.location ==2)|| (vinf.location ==1) ||(vinf.location < 0))
              if(params == null)
                return s.toUpperCase();
              else{//is array
                s = s.toUpperCase();
                String S1 = s;
                
                for( int i=0; i< params.length; i++){
                     s +="[(int)("+params[i]+"-"+Offset(S1,i)+")]";
                    
                 }
                 return s;
              }
           else{//Function
              s1= util.JavaInvokeIntrinsic( s, params);
              if( s1 == null)
                s1= util.LocalInvokeFxnCode( s, params);
              if(s1 == null){
                s1=util.OperatorInvokeFxnCode( s, params);
                if(vinf.DataType.equals("String"))
                  s1 +=".toString()";
                else if( vinf.DataType.equals("boolean"))
                  s1="((Boolean)("+s+").getbooleanValue())";
                else
                  s1="((Number)"+s1+")."+vinf.DataType+"Value()";
                threwException = true;   
               return s1;
              }
           }
        }

     }|
   s=Number()
     {
       return s;

     }|
   t1=<STRING>
     {
       return "\""+t1.image+"\"";

     }|
   <LPAREN> s=Expression("") <RPAREN>
     {
       return "("+s+")";
     }
 }

/*------------------ Number------------------------*/
String Number():{
 Token t1=null,
       t2=null,
       t3=null;
 String s="";
  
 }
 {
   t1=<INTNUM> [t3=<DOT>[t2=<INTNUM>]][s=ExponentialExpression()]
     { 
       if(t2 == null)
         if( t3==null)
           return t1.image+s;

         else 
           return t1.image+"."+s;

       else
         return t1.image+"."+t2.image+s; 

     }|
   <DOT>t1=<INTNUM>[s=ExponentialExpression()]
     {
        return "."+t1.image+s;

      }

 }


String ExponentialExpression():{
 Token t=null,
       t1=null;
 String //s,
        pm;
 }
 {
    <EXP>[(t1=<PLUS>|t1=<MINUS>)] t=<INTNUM>
     { 
       pm="";
       if( t1 != null)
         if( t1.kind==MINUS)
           pm="-";

       return "E"+pm+t.image;

     }
 }

void NumTerminator():
 {
 }
 {
   <EOLN> |
   <RPAREN> |
   <COMMA> |
   <PLUS> |
   <MINUS> |
   <PROD> |
   <DIVISION> |
   <POWER>
  
 }

/*--------------------- List to get tokens into constants -----------------------*/
void Expression7():{


}
{

  <EOF>|
  <MATHOP>|
  <LPAREN>|
  <IDENTIFIER>|
  <FLOATNUM>|
  <INTNUM>|
  <ERROR>|
  <EOLN> |
  <RPAREN> |
  <COMMA> |
  <PLUS> |
  <MINUS> |
  <PROD> |
  <DIVISION> |
  <POWER>|
  <IF> |
  <THEN>|
  <DO> |
  <EQUALS> |
  <WRITE> |
  <READ> |
  <LT> |
  <GT> |
  <LE> |
  <GE> |
  <EQ> |
  <AND>|
  <OR> |
  <NOT> |
  <INTEGER> |
  <REAL> |
  <DIMENSION> |
  <CHARACTER> |
  <LOGICAL> |
  <EXTERNAL> |
  <ENDIF> |
  <ELSE>|
  <SUBROUTINE>|
  <FUNCTION>|
  <CONTINUE>|
  <LABEL>|
  <STRING>|
  <COMMENT>|
  <DOT>|
  <NE>|
  <EXP>|<END>|<LOGDOT>
 }

String PossVarName():{
  Token t;
}{ t=<IDENTIFIER>{return t.image;}
  |<SUBROUTINE>{return "SUBROUTINE";}
  |<FUNCTION>{return "FUNCTION";}|<THEN>{return "THEN";}|
  <IF>{return "IF";} |<DO>{return "DO";}|<WRITE>{return "WRITE";} |
  <READ>{return "READ";} |<INTEGER>{return "INTEGER";} |<REAL>{return "REAL";} |
  <DIMENSION> {return "DIMENSION";}|<CHARACTER>{return "CHARACTER";} |<LOGICAL>{return "LOGICAL";} |
   <EXTERNAL>{return "EXTERNAL";} |<ENDIF>{return "ENDIF";} |
  <ELSE>{return "ELSE";}|<CONTINUE>{return "CONTINUE";}|
  <EXP>{return "EXP";} |<WHILE>{return "WHILE";}|<TRUE>{return "TRUE";}|
<FALSE>{return "FALSE";}|<CALL>{return "CALL";} |<RETURN>{return "RETURN";}
}
/*-------------------------  Lists --------------------------------*/

String[] ExpressionList():{
 //Token t;
 String[] Res= new String[0], 
          Res1;;
 String s="",
        s1="";
}
{ <LPAREN> [s = Expression("") 
               (<COMMA> s1=Expression("")
                  { Res1 = new String[Res.length+1];
                    System.arraycopy( Res,0,Res1,0,Res.length);
                    Res1[Res1.length-1]= s1;
                    Res=Res1;
                  }
                )*
             ]   

     <RPAREN>
  {
    Res1 = new String[Res.length+1];
    System.arraycopy( Res,0,Res1,1,Res.length);
    Res1[0]= s;
    return Res1;
  }
}

String[] ArgList():{
  String s=null;//s1=null,s2;
  String[] Res;
  //Token t;
  LinkedList LL = new LinkedList();
}{

  <LPAREN> [
             (s=Expression("") |<PROD>)
             {if( s != null)
                 LL.add( s);
              else 
                 LL.add( "*");
             }
               (
                 <COMMA>(s=Expression("") |<PROD>)
                    {if( s != null)
                       LL.add( s);
                     else 
                        LL.add( "*");
                     }
               )*

           ]
  <RPAREN>{
     Res = new String[LL.size()];
     if(Res.length <1) 
       return Res;
     ListIterator Lit = LL.listIterator(0);
     int i=0;
     while( Lit.hasNext()){

       Res[i]=(String)Lit.next();
       i++;
    }
    return Res;
  }

}

